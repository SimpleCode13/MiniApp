<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Run Poizon — калькулятор + игры</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
:root {
    --tg-bg: #0a0c10;
    --tg-fg: #ffffff;
    --tg-accent: #00d4ff;
    --tg-accent-2: #7c3aed;
    --card-bg: #141821;
    --card-bg-light: #1a1f2e;
    --border: #2a3441;
    --border-light: #374151;
    --shadow: 0 8px 20px rgba(0,0,0,0.3);
    --shadow-hover: 0 15px 30px rgba(0,0,0,0.5);
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
    --gradient: linear-gradient(135deg, var(--tg-accent), var(--tg-accent-2));
    --gradient-2: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --gradient-3: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
}

* {
    box-sizing: border-box;
}

body {
    font-family: -apple-system, system-ui, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans";
    background: linear-gradient(135deg, var(--tg-bg) 0%, #0f1419 50%, #1a1f2e 100%);
    color: var(--tg-fg);
    margin: 0;
    padding: 12px 12px 80px;
    display: flex;
    justify-content: center;
    min-height: 100vh;
    overflow-x: hidden;
    position: relative;
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 20% 80%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(124, 58, 237, 0.1) 0%, transparent 50%);
    pointer-events: none;
    z-index: -1;
}

.wrap {
    width: 100%;
    max-width: 420px;
    position: relative;
}

.card {
    background: var(--card-bg);
    border-radius: 20px;
    padding: 20px;
    box-shadow: var(--shadow);
    text-align: center;
    position: relative;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
    border: 1px solid var(--border);
    backdrop-filter: blur(10px);
}

.card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: var(--gradient);
    opacity: 0.9;
    border-radius: 20px 20px 0 0;
}

.card::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: conic-gradient(from 0deg, transparent, rgba(0, 212, 255, 0.03), transparent);
    animation: cardRotate 20s linear infinite;
    z-index: -1;
}

@keyframes cardRotate {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.logo-title {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 20px;
    position: relative;
}

.logo-title .logo-icon {
    width: 50px;
    height: 50px;
    border-radius: 12px;
    margin-bottom: 12px;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 6px 20px rgba(0, 212, 255, 0.3);
    border: 2px solid rgba(0, 212, 255, 0.2);
    background: var(--gradient);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
}

.logo-title .logo-icon:hover {
    transform: scale(1.1) rotate(8deg);
    box-shadow: 0 10px 30px rgba(0, 212, 255, 0.5);
}

.logo-title span {
    color: var(--tg-fg);
    font-weight: 900;
    font-size: 22px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
}

.calculator-form {
    margin-bottom: 20px;
}

label {
    display: block;
    margin: 15px 0 8px;
    font-weight: 700;
    text-align: left;
    font-size: 14px;
    color: var(--tg-fg);
    opacity: 0.95;
}

input, select {
    width: 100%;
    padding: 12px 14px;
    border: 2px solid var(--border);
    border-radius: 12px;
    background: var(--card-bg-light);
    color: var(--tg-fg);
    font-size: 14px;
    transition: all 0.3s ease;
    outline: none;
    backdrop-filter: blur(10px);
}

input:focus, select:focus {
    border-color: var(--tg-accent);
    box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.15);
    transform: translateY(-1px);
    background: var(--card-bg);
}

input:hover, select:hover {
    border-color: var(--border-light);
    transform: translateY(-1px);
}

input::placeholder {
    color: rgba(255, 255, 255, 0.4);
}

.btn {
    width: 100%;
    padding: 14px;
    background: var(--gradient);
    border: none;
    color: white;
    font-size: 16px;
    font-weight: 800;
    border-radius: 12px;
    cursor: pointer;
    margin-top: 18px;
    position: relative;
    overflow: hidden;
    transition: all 0.4s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 6px 20px rgba(0, 212, 255, 0.3);
}

.btn::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
    transform: rotate(45deg);
    transition: all 0.5s;
    opacity: 0;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 30px rgba(0, 212, 255, 0.4);
}

.btn:hover::before {
    animation: shimmer 0.6s ease;
}

@keyframes shimmer {
    0% { left: -100%; opacity: 0; }
    50% { opacity: 1; }
    100% { left: 100%; opacity: 0; }
}

.btn:active {
    transform: translateY(-1px);
}

.btn-loader {
    width: 18px;
    height: 18px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top: 2px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    display: none;
}

.btn.loading .btn-text {
    opacity: 0.7;
}

.btn.loading .btn-loader {
    display: block;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.muted {
    opacity: 0.7;
    font-size: 12px;
    margin-top: 12px;
    text-align: left;
    line-height: 1.4;
    color: var(--tg-fg);
}

#result {
    margin-top: 18px;
    font-size: 16px;
    font-weight: 700;
    white-space: pre-line;
    text-align: center;
    padding: 18px;
    background: linear-gradient(135deg, #1a2f4b 0%, #2d1b69 100%);
    border-radius: 16px;
    border: 2px solid var(--tg-accent);
    transition: all 0.4s ease;
    transform: translateY(15px);
    opacity: 0;
    color: var(--tg-fg);
    backdrop-filter: blur(15px);
    box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
    position: relative;
    overflow: hidden;
}

#result::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
    animation: resultShine 2s infinite;
}

@keyframes resultShine {
    0% { left: -100%; }
    100% { left: 100%; }
}

#result.show {
    transform: translateY(0);
    opacity: 1;
}

.result-header {
    font-size: 18px;
    font-weight: 900;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 12px;
}

.result-price {
    font-size: 26px;
    font-weight: 900;
    color: #00ff88;
    text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    margin: 12px 0;
}

.result-details {
    font-size: 12px;
    opacity: 0.8;
    line-height: 1.5;
    margin-top: 12px;
}

#mainCoinCounter {
    position: absolute;
    top: 16px;
    right: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 900;
    color: var(--tg-accent);
    background: linear-gradient(135deg, rgba(0, 212, 255, 0.15), rgba(124, 58, 237, 0.15));
    padding: 8px 12px;
    border-radius: 20px;
    transition: all 0.4s ease;
    border: 1px solid var(--border);
    backdrop-filter: blur(15px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    font-size: 14px;
}

#mainCoinCounter:hover {
    transform: scale(1.05);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
}

#mainCoinCounter .coin-icon {
    width: 20px;
    height: 20px;
    animation: coinFloat 3s ease-in-out infinite;
    filter: drop-shadow(0 3px 6px rgba(0, 212, 255, 0.3));
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
}

@keyframes coinFloat {
    0%, 100% { transform: translateY(0px) rotate(0deg); }
    50% { transform: translateY(-3px) rotate(180deg); }
}

.playbar {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 12px 16px calc(env(safe-area-inset-bottom) + 12px);
    background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.4) 20%), var(--tg-bg);
    display: flex;
    justify-content: center;
    border-top: 1px solid var(--border);
    z-index: 10;
    backdrop-filter: blur(20px);
}

.play-btn {
    max-width: 420px;
    width: calc(100% - 32px);
    background: var(--gradient);
    color: #fff;
    border: none;
    border-radius: 16px;
    padding: 16px;
    font-size: 16px;
    font-weight: 900;
    box-shadow: var(--shadow);
    cursor: pointer;
    transition: all 0.4s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    position: relative;
    overflow: hidden;
}

.play-btn::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
    transform: rotate(45deg);
    transition: all 0.5s;
    opacity: 0;
}

.play-btn:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow-hover);
}

.play-btn:hover::before {
    animation: shimmer 0.6s ease;
}

.game-icon {
    font-size: 20px;
    animation: gameIconPulse 2.5s ease-in-out infinite;
}

@keyframes gameIconPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
}

.overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.7);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 50;
    backdrop-filter: blur(12px);
    animation: overlayFadeIn 0.4s ease;
}

.overlay.show {
    display: flex;
}

@keyframes overlayFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.game-card {
    width: 96vw;
    max-width: 500px;
    max-height: 90vh;
    background: var(--card-bg);
    border-radius: 20px;
    box-shadow: var(--shadow-hover);
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-y: auto;
    animation: gameCardSlideIn 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    border: 1px solid var(--border);
    backdrop-filter: blur(15px);
}

@keyframes gameCardSlideIn {
    from {
        opacity: 0;
        transform: translateY(40px) scale(0.9);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.game-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px 16px;
    width: 100%;
    border-bottom: 1px solid var(--border);
    margin-bottom: 20px;
}

.game-title {
    font-weight: 900;
    font-size: 18px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.close-btn {
    border: 2px solid var(--border);
    background: var(--card-bg-light);
    color: var(--tg-fg);
    padding: 8px 16px;
    border-radius: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    font-size: 14px;
}

.close-btn:hover {
    border-color: var(--danger);
    color: var(--danger);
    transform: scale(1.05);
    background: rgba(239, 68, 68, 0.1);
}

.games-grid {
    display: grid;
    gap: 16px;
    width: 100%;
}

.game-choice-btn {
    width: 100%;
    padding: 20px;
    font-size: 15px;
    font-weight: 800;
    border-radius: 16px;
    cursor: pointer;
    transition: all 0.4s ease;
    border: 2px solid var(--border);
    background: linear-gradient(135deg, var(--card-bg-light), var(--card-bg));
    color: var(--tg-fg);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    text-align: center;
    position: relative;
    overflow: hidden;
    backdrop-filter: blur(10px);
}

.game-choice-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: var(--gradient);
    opacity: 0;
    transition: all 0.3s ease;
}

.game-choice-btn:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-hover);
    border-color: var(--tg-accent);
}

.game-choice-btn:hover::before {
    opacity: 1;
}

.game-emoji {
    font-size: 32px;
    margin-bottom: 6px;
    animation: gameEmojiFloat 3s ease-in-out infinite;
}

@keyframes gameEmojiFloat {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-4px); }
}

.game-name {
    font-size: 16px;
    font-weight: 900;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.game-desc {
    font-size: 12px;
    opacity: 0.8;
    font-weight: 600;
    color: var(--tg-fg);
}

.game-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    width: 100%;
    margin-bottom: 20px;
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.control-group label {
    font-size: 13px;
    font-weight: 700;
    margin: 0;
    text-align: center;
    color: var(--tg-fg);
}

.control-group input,
.control-group select {
    padding: 10px;
    font-size: 13px;
    border-radius: 10px;
}

.game-info {
    display: flex;
    justify-content: space-between;
    width: 100%;
    margin-bottom: 16px;
    padding: 12px;
    background: linear-gradient(135deg, rgba(0, 212, 255, 0.12), rgba(124, 58, 237, 0.12));
    border-radius: 12px;
    border: 1px solid var(--border);
    backdrop-filter: blur(10px);
}

.game-info div {
    font-weight: 800;
    font-size: 13px;
    color: var(--tg-fg);
}

.game-btn {
    padding: 12px 24px;
    border: none;
    border-radius: 12px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.4s ease;
    margin: 8px 0;
    min-width: 140px;
    font-size: 14px;
    position: relative;
    overflow: hidden;
}

.game-btn::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
    transform: rotate(45deg);
    transition: all 0.5s;
    opacity: 0;
}

.game-btn.primary {
    background: var(--gradient);
    color: white;
    box-shadow: 0 5px 16px rgba(0, 212, 255, 0.3);
}

.game-btn.success {
    background: linear-gradient(135deg, var(--success), #059669);
    color: white;
    box-shadow: 0 5px 16px rgba(16, 185, 129, 0.3);
}

.game-btn.secondary {
    background: var(--card-bg-light);
    border: 2px solid var(--border) !important;
    color: var(--tg-fg);
    backdrop-filter: blur(10px);
}

.game-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
}

.game-btn:hover::before {
    animation: shimmer 0.6s ease;
}

.game-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

#minerGrid {
    display: grid;
    grid-template-columns: repeat(5, 50px);
    grid-gap: 8px;
    margin: 16px 0;
    padding: 16px;
    background: linear-gradient(135deg, rgba(42, 47, 58, 0.4), rgba(30, 35, 48, 0.4));
    border-radius: 16px;
    border: 1px solid var(--border);
    backdrop-filter: blur(10px);
    box-shadow: inset 0 3px 10px rgba(0, 0, 0, 0.2);
}

.cell {
    width: 50px;
    height: 50px;
    background: linear-gradient(145deg, #4a5568, #2d3748);
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.4s ease;
    position: relative;
    border: 2px solid transparent;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    font-size: 20px;
}

.cell:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(0, 212, 255, 0.3);
    border-color: var(--tg-accent);
}

.cell.clicked {
    background: linear-gradient(145deg, #10b981, #059669);
    border-color: var(--success);
    box-shadow: 0 5px 16px rgba(16, 185, 129, 0.4);
}

.cell.mine {
    background: linear-gradient(145deg, #ef4444, #dc2626);
    border-color: var(--danger);
    box-shadow: 0 5px 16px rgba(239, 68, 68, 0.4);
}

.cell .cell-content {
    display: none;
    pointer-events: none;
    filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.5));
}

.cell.explode .cell-content {
    display: block;
    animation: explode 1s forwards;
}

.cell.win .cell-content {
    display: block;
    animation: winPulse 0.6s ease;
}

@keyframes explode {
    0% { transform: scale(1) rotate(0deg); opacity: 1; }
    50% { transform: scale(1.6) rotate(180deg); opacity: 0.8; }
    100% { transform: scale(0.2) rotate(360deg); opacity: 0; }
}

@keyframes winPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
}

#minerMsg {
    margin: 12px 0;
    font-weight: 800;
    font-size: 15px;
    min-height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--tg-fg);
}

.miner-stats,
.run-stats,
.roulette-stats {
    display: flex;
    justify-content: space-around;
    width: 100%;
    margin-top: 16px;
    padding-top: 16px;
    border-top: 1px solid var(--border);
}

.stat {
    text-align: center;
    font-size: 11px;
    opacity: 0.9;
    color: var(--tg-fg);
    font-weight: 600;
}

.stat span {
    display: block;
    font-weight: 900;
    font-size: 14px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-top: 4px;
}

#runCanvas {
    width: 100%;
    height: 220px;
    border: 2px solid var(--border);
    border-radius: 16px;
    background: linear-gradient(180deg, #4dd0e1 0%, #81c784 30%, #aed581 70%, #8bc34a 100%);
    margin-bottom: 12px;
    box-shadow: inset 0 3px 10px rgba(0,0,0,0.2), 0 6px 20px rgba(0, 0, 0, 0.3);
    position: relative;
    overflow: hidden;
}

#runCanvas::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 70% 20%, rgba(255, 255, 255, 0.2) 0%, transparent 50%);
    pointer-events: none;
}

.score {
    font-weight: 900;
    margin: 12px 0;
    text-align: center;
    font-size: 16px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.game-cta {
    display: flex;
    gap: 12px;
    margin: 16px 0;
    width: 100%;
}

.game-cta button {
    flex: 1;
    padding: 12px;
    border-radius: 12px;
    border: none;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.4s ease;
    font-size: 14px;
}

.primary {
    background: var(--gradient);
    color: #fff;
    box-shadow: 0 5px 16px rgba(0, 212, 255, 0.3);
}

.secondary {
    background: var(--card-bg-light);
    border: 2px solid var(--border) !important;
    color: var(--tg-fg);
    backdrop-filter: blur(10px);
}

.primary:hover,
.secondary:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
}

/* УЛУЧШЕННАЯ РУЛЕТКА */
.roulette-wheel {
    width: 220px;
    height: 220px;
    border-radius: 50%;
    border: 6px solid #ffd700;
    position: relative;
    margin: 16px auto;
    background: conic-gradient(
        from 0deg,
        #ff0000 0deg 36deg,
        #000000 36deg 72deg,
        #ff0000 72deg 108deg,
        #000000 108deg 144deg,
        #ff0000 144deg 180deg,
        #000000 180deg 216deg,
        #ff0000 216deg 252deg,
        #000000 252deg 288deg,
        #ff0000 288deg 324deg,
        #000000 324deg 347deg,
        #00ff00 347deg 360deg
    );
    box-shadow: 0 0 25px rgba(255, 215, 0, 0.6), inset 0 0 15px rgba(0, 0, 0, 0.3);
    transition: transform 3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.roulette-center {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 50px;
    height: 50px;
    background: linear-gradient(45deg, #ffd700, #ffed4e);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    font-weight: 900;
    color: #000;
    z-index: 2;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
    border: 3px solid rgba(255, 255, 255, 0.3);
}

.roulette-pointer {
    position: absolute;
    top: -12px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 12px solid transparent;
    border-right: 12px solid transparent;
    border-top: 24px solid #ffd700;
    z-index: 3;
    filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.4));
}

.roulette-bets {
    display: flex;
    gap: 8px;
    margin: 16px 0;
    justify-content: center;
}

.bet-option {
    flex: 1;
    padding: 12px 8px;
    border-radius: 10px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 800;
    font-size: 12px;
    text-align: center;
    position: relative;
    overflow: hidden;
}

.bet-option::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.bet-option.red {
    background: linear-gradient(135deg, #ff4757, #ff3742);
    color: white;
    box-shadow: 0 3px 10px rgba(255, 71, 87, 0.3);
}

.bet-option.black {
    background: linear-gradient(135deg, #2f3542, #1e2128);
    color: white;
    box-shadow: 0 3px 10px rgba(47, 53, 66, 0.3);
}

.bet-option.green {
    background: linear-gradient(135deg, #2ed573, #1dd1a1);
    color: white;
    box-shadow: 0 3px 10px rgba(46, 213, 115, 0.3);
}

.bet-option:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
}

.bet-option:hover::before {
    opacity: 1;
}

.bet-option.selected {
    border-color: #ffd700;
    box-shadow: 0 0 12px rgba(255, 215, 0, 0.6);
    transform: scale(1.05);
}

.roulette-result {
    margin: 16px 0;
    padding: 16px;
    border-radius: 12px;
    font-weight: 700;
    font-size: 16px;
    text-align: center;
    display: none;
}

.roulette-result.win {
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.2));
    border: 2px solid var(--success);
    color: var(--success);
}

.roulette-result.lose {
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.2));
    border: 2px solid var(--danger);
    color: var(--danger);
}

#notificationBox {
    position: fixed;
    top: 20px;
    right: 20px;
    background: var(--card-bg);
    border-radius: 12px;
    padding: 16px 20px;
    box-shadow: var(--shadow-hover);
    font-weight: 700;
    z-index: 1000;
    transform: translateX(400px);
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    border-left: 4px solid var(--tg-accent);
    max-width: 300px;
    color: var(--tg-fg);
    border: 1px solid var(--border);
    backdrop-filter: blur(15px);
    font-size: 14px;
}

#notificationBox.show {
    transform: translateX(0);
}

#notificationBox.error {
    border-left-color: var(--danger);
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), var(--card-bg));
}

#notificationBox.success {
    border-left-color: var(--success);
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), var(--card-bg));
}

#notificationBox.warning {
    border-left-color: var(--warning);
    background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), var(--card-bg));
}

#loadingScreen {
    position: fixed;
    inset: 0;
    background: var(--tg-bg);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    opacity: 1;
    transition: opacity 0.6s ease;
}

#loadingScreen.hidden {
    opacity: 0;
    pointer-events: none;
}

.loading-content {
    text-align: center;
}

.loading-logo {
    width: 70px;
    height: 70px;
    border-radius: 18px;
    margin-bottom: 20px;
    animation: loadingBounce 2s ease-in-out infinite;
    box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4);
    border: 3px solid rgba(0, 212, 255, 0.3);
    background: var(--gradient);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
}

@keyframes loadingBounce {
    0%, 100% { transform: translateY(0px) scale(1); }
    50% { transform: translateY(-20px) scale(1.1); }
}

.loading-text {
    font-size: 18px;
    font-weight: 800;
    margin-bottom: 20px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.loading-bar {
    width: 200px;
    height: 5px;
    background: var(--border);
    border-radius: 3px;
    overflow: hidden;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
}

.loading-progress {
    height: 100%;
    background: var(--gradient);
    width: 0%;
    animation: loadingProgress 2.5s ease-in-out infinite;
    border-radius: 3px;
}

@keyframes loadingProgress {
    0% { width: 0%; }
    50% { width: 80%; }
    100% { width: 100%; }
}

/* Responsive Design */
@media (max-width: 480px) {
    body {
        padding: 10px 10px 70px;
    }

    .card {
        padding: 16px;
        border-radius: 16px;
    }

    .logo-title .logo-icon {
        width: 45px;
        height: 45px;
        font-size: 20px;
    }

    .logo-title span {
        font-size: 20px;
    }

    .game-controls {
        grid-template-columns: 1fr;
        gap: 12px;
    }

    #minerGrid {
        grid-template-columns: repeat(5, 45px);
        grid-gap: 6px;
        padding: 12px;
    }

    .cell {
        width: 45px;
        height: 45px;
        font-size: 18px;
    }

    #runCanvas {
        height: 180px;
    }

    .roulette-wheel {
        width: 180px;
        height: 180px;
    }

    .roulette-bets {
        flex-direction: column;
        gap: 6px;
    }

    .bet-option {
        padding: 10px;
    }
}

/* Accessibility */
@media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* Focus styles for accessibility */
button:focus-visible,
input:focus-visible,
select:focus-visible {
    outline: 3px solid var(--tg-accent);
    outline-offset: 2px;
}

/* Print styles */
@media print {
    .playbar,
    .overlay,
    #notificationBox {
        display: none !important;
    }

    .card {
        box-shadow: none;
        border: 1px solid #ccc;
    }
}
    </style>
</head>
<body>
    <div class="wrap">
        <div class="card">
            <div id="mainCoinCounter">
                <div class="coin-icon">🪙</div>
                <span id="mainCoins">10</span>
            </div>

            <div class="logo-title">
                <div class="logo-icon">⚡</div>
                <span>Калькулятор</span>
            </div>

            <div class="calculator-form">
                <label for="price">Цена в юанях</label>
                <input type="number" id="price" placeholder="Например, 500" inputmode="decimal"/>

                <label for="category">Категория</label>
                <select id="category">
                    <option value="Футболка / майка / рубашка">Футболка / майка / рубашка</option>
                    <option value="Брюки / джинсы">Брюки / джинсы</option>
                    <option value="Худи / толстовка / свитшот">Худи / толстовка / свитшот</option>
                    <option value="Сумка / рюкзак">Сумка / рюкзак</option>
                    <option value="Поясная сумка">Поясна я сумка</option>
                    <option value="Шапка/ шарф / носки">Шапка/ шарф / носки</option>
                    <option value="Ветровка / куртка">Ветровка / куртка</option>
                    <option value="Кроссовки / кеды / ботинки">Кроссовки / кеды / ботинки</option>
                    <option value="Зимняя обувь">Зимняя обувь</option>
                </select>

                <button class="btn" id="calcBtn">
                    <span class="btn-text">Рассчитать</span>
                    <span class="btn-loader"></span>
                </button>

                <div id="result"></div>
                <div class="muted">После расчёта результат отправится в чат бота.</div>
            </div>
        </div>
    </div>

    <!-- Error/Success notifications -->
    <div id="notificationBox"></div>

    <!-- Game Button -->
    <div class="playbar">
        <button class="play-btn" id="openGame">
            <span class="game-icon">🎮</span>
            <span>Играть</span>
        </button>
    </div>

    <!-- Game Overlay -->
    <div class="overlay" id="overlay">
        <!-- Game Selection -->
        <div class="game-card" id="gameSelectCard">
            <div class="game-header">
                <div class="game-title">Выберите игру</div>
                <button class="close-btn" id="closeGame">Закрыть</button>
            </div>
            <div class="games-grid">
                <button class="game-choice-btn" id="selectMiner">
                    <span class="game-emoji">💣</span>
                    <span class="game-name">Poizon Miner</span>
                    <span class="game-desc">Найди алмазы, избегай мин</span>
                </button>
                <button class="game-choice-btn" id="selectRun">
                    <span class="game-emoji">🏃</span>
                    <span class="game-name">Run Poizon</span>
                    <span class="game-desc">Беги и собирай монеты</span>
                </button>
                <button class="game-choice-btn" id="selectRoulette">
                    <span class="game-emoji">🎰</span>
                    <span class="game-name">Рулетка</span>
                    <span class="game-desc">Красное, черное или зеленое</span>
                </button>
            </div>
        </div>

        <!-- Miner Game -->
        <div class="game-card" id="minerCard" style="display:none;">
            <div class="game-header">
                <div class="game-title">💣 Poizon Miner</div>
                <button class="close-btn" id="closeMiner">Закрыть</button>
            </div>

            <div id="minerBet" class="game-controls">
                <div class="control-group">
                    <label>Ставка (монеты)</label>
                    <input type="number" id="minerStake" min="1" placeholder="1" value="1">
                </div>
                <div class="control-group">
                    <label>Количество мин</label>
                    <select id="numMines">
                        <option value="3">3 мины (легко)</option>
                        <option value="4">4 мины</option>
                        <option value="5" selected>5 мины (норм)</option>
                        <option value="6">6 мины</option>
                        <option value="7">7 мины</option>
                        <option value="8">8 мины (сложно)</option>
                        <option value="9">9 мины</option>
                        <option value="10">10 мины (экстрим)</option>
                    </select>
                </div>
            </div>

            <div class="game-info">
                <div id="multiplier">Множитель: 0.0x</div>
                <div id="currentPrize">Приз: 0 монет</div>
            </div>

            <button class="game-btn primary" id="startMinerGame">Начать игру</button>
            <div id="minerGrid"></div>
            <button class="game-btn success" id="takePrize" disabled>Забрать приз</button>
            <div id="minerMsg"></div>

            <div class="miner-stats">
                <div class="stat">Игр: <span id="minerGamesCount">0</span></div>
                <div class="stat">Побед: <span id="minerWins">0</span></div>
                <div class="stat">Лучший приз: <span id="minerBestPrize">0</span></div>
            </div>
        </div>

        <!-- Run Game -->
        <div class="game-card" id="runCard" style="display:none;">
            <div class="game-header">
                <div class="game-title">🏃 Run Poizon</div>
                <button class="close-btn" id="closeRun">Закрыть</button>
            </div>

            <canvas id="runCanvas" width="480" height="220"></canvas>
            <div class="score" id="runScore">Счёт: 0 • 🏆 Рекорд: 0</div>

            <div class="game-cta">
                <button class="secondary" id="tapBtn">Прыжок</button>
                <button class="primary" id="restartRunBtn">Старт/Рестарт</button>
            </div>

            <div class="run-stats">
                <div class="stat">Игр: <span id="runGamesCount">0</span></div>
                <div class="stat">Монет собрано: <span id="runCoinsCollected">0</span></div>
            </div>
        </div>

        <!-- Roulette Game -->
        <div class="game-card" id="rouletteCard" style="display:none;">
            <div class="game-header">
                <div class="game-title">🎰 Рулетка</div>
                <button class="close-btn" id="closeRoulette">Закрыть</button>
            </div>

            <div class="game-controls">
                <div class="control-group">
                    <label>Ставка (монеты)</label>
                    <input type="number" id="rouletteStake" min="1" placeholder="1" value="1">
                </div>
                <div class="control-group">
                    <label>Выберите цвет</label>
                    <div class="roulette-bets">
                        <div class="bet-option red" data-color="red">
                            Красное<br>x2.0
                        </div>
                        <div class="bet-option black" data-color="black">
                            Черное<br>x2.0
                        </div>
                        <div class="bet-option green" data-color="green">
                            Зеленое<br>x14.0
                        </div>
                    </div>
                </div>
            </div>

            <div class="roulette-wheel" id="rouletteWheel">
                <div class="roulette-pointer"></div>
                <div class="roulette-center">🎯</div>
            </div>

            <button class="game-btn primary" id="spinRoulette">Крутить рулетку!</button>

            <div id="rouletteResult" class="roulette-result"></div>
            <div id="rouletteMsg"></div>

            <div class="roulette-stats">
                <div class="stat">Игр: <span id="rouletteGamesCount">0</span></div>
                <div class="stat">Побед: <span id="rouletteWins">0</span></div>
                <div class="stat">Лучший выигрыш: <span id="rouletteBestWin">0</span></div>
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loading-content">
            <div class="loading-logo">⚡</div>
            <div class="loading-text">Загрузка...</div>
            <div class="loading-bar">
                <div class="loading-progress"></div>
            </div>
        </div>
    </div>

    <script>
// ====================
// Global Variables & State Management
// ====================
class GameState {
    constructor() {
        this.coins = this.loadData('coins', 10);
        this.stats = this.loadData('stats', {
            calcCount: 0,
            gamesPlayed: 0,
            bestScore: 0,
            minerGamesCount: 0,
            minerWins: 0,
            minerBestPrize: 0,
            runGamesCount: 0,
            runCoinsCollected: 0,
            rouletteGamesCount: 0,
            rouletteWins: 0,
            rouletteBestWin: 0
        });
        this.settings = this.loadData('settings', {
            animationsEnabled: true,
            soundEnabled: false
        });
    }

    loadData(key, defaultValue) {
        try {
            const saved = localStorage.getItem(`poizon_${key}`);
            return saved ? JSON.parse(saved) : defaultValue;
        } catch (e) {
            console.warn(`Failed to load ${key}:`, e);
            return defaultValue;
        }
    }

    saveData(key, value) {
        try {
            localStorage.setItem(`poizon_${key}`, JSON.stringify(value));
        } catch (e) {
            console.warn(`Failed to save ${key}:`, e);
        }
    }

    updateCoins(amount) {
        this.coins = Math.max(0, this.coins + amount);
        this.saveData('coins', this.coins);
        this.updateUI();
    }

    updateStats(key, value) {
        this.stats[key] = value;
        this.saveData('stats', this.stats);
        this.updateUI();
    }

    updateUI() {
        document.getElementById('mainCoins').textContent = this.coins.toFixed(1);

        // Update miner stats if elements exist
        const minerGamesEl = document.getElementById('minerGamesCount');
        if (minerGamesEl) minerGamesEl.textContent = this.stats.minerGamesCount;

        const minerWinsEl = document.getElementById('minerWins');
        if (minerWinsEl) minerWinsEl.textContent = this.stats.minerWins;

        const minerBestPrizeEl = document.getElementById('minerBestPrize');
        if (minerBestPrizeEl) minerBestPrizeEl.textContent = this.stats.minerBestPrize.toFixed(1);

        const runGamesEl = document.getElementById('runGamesCount');
        if (runGamesEl) runGamesEl.textContent = this.stats.runGamesCount;

        const runCoinsEl = document.getElementById('runCoinsCollected');
        if (runCoinsEl) runCoinsEl.textContent = this.stats.runCoinsCollected.toFixed(1);

        // Update roulette stats if elements exist
        const rouletteGamesEl = document.getElementById('rouletteGamesCount');
        if (rouletteGamesEl) rouletteGamesEl.textContent = this.stats.rouletteGamesCount;

        const rouletteWinsEl = document.getElementById('rouletteWins');
        if (rouletteWinsEl) rouletteWinsEl.textContent = this.stats.rouletteWins;

        const rouletteBestWinEl = document.getElementById('rouletteBestWin');
        if (rouletteBestWinEl) rouletteBestWinEl.textContent = this.stats.rouletteBestWin.toFixed(1);
    }
}

// ====================
// Utility Functions
// ====================
class Utils {
    static showNotification(message, type = 'info', duration = 3000) {
        const notificationBox = document.getElementById('notificationBox');
        notificationBox.textContent = message;
        notificationBox.className = `show ${type}`;

        setTimeout(() => {
            notificationBox.classList.remove('show');
        }, duration);
    }

    static formatNumber(num) {
        return new Intl.NumberFormat('ru-RU', {
            minimumFractionDigits: 0,
            maximumFractionDigits: 2
        }).format(num);
    }

    static generateId() {
        return Math.random().toString(36).substr(2, 9);
    }

    static clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }

    static lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    static randomBetween(min, max) {
        return Math.random() * (max - min) + min;
    }
}

// ====================
// Calculator Module
// ====================
class Calculator {
    constructor(gameState) {
        this.gameState = gameState;
        this.formulas = {
            "Футболка / майка / рубашка": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 772.31 + 1000,
            "Брюки / джинсы": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 1019.91 + 1000,
            "Худи / толстовка / свитшот": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 1081.81 + 1000,
            "Сумка / рюкзак": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 1453.21 + 1000,
            "Поясная сумка": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 772.31 + 1000,
            "Шапка/ шарф / носки": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 772.31 + 1000,
            "Ветровка / куртка": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 1453.21 + 1000,
            "Кроссовки / кеды / ботинки": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 1733.59 + 1000,
            "Зимняя обувь": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 2104.99 + 1000
        };
        this.init();
    }

    init() {
        document.getElementById('calcBtn').addEventListener('click', () => this.calculate());

        // Enter key support
        document.getElementById('price').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.calculate();
        });
    }

    async calculate() {
        const btn = document.getElementById('calcBtn');
        const resultEl = document.getElementById('result');
        const priceInput = document.getElementById('price');
        const categorySelect = document.getElementById('category');

        const price = parseFloat(priceInput.value);
        const category = categorySelect.value;

        if (isNaN(price) || price <= 0) {
            Utils.showNotification("⚠️ Введите корректную цену!", 'warning');
            priceInput.focus();
            return;
        }

        if (price > 1000000) {
            Utils.showNotification("⚠️ Цена слишком высокая!", 'warning');
            return;
        }

        // Loading state
        btn.classList.add('loading');
        btn.disabled = true;

        try {
            // Simulate calculation delay for better UX
            await new Promise(resolve => setTimeout(resolve, 800));

            const result = this.formulas[category](price);
            const commission = price > 1526 ? price * 0.15 : 0;

            const resultHTML = `
                <div class="result-header">💰 РЕЗУЛЬТАТ РАСЧЁТА</div>
                <div class="result-price">${Utils.formatNumber(result)} ₽</div>
                <div class="result-details">
                    📦 Категория: ${category}<br>
                    💸 Цена товара: ${Utils.formatNumber(price)} ¥<br>
                    ${commission > 0 ? `📊 Комиссия: ${Utils.formatNumber(commission)} ¥<br>` : ''}
                    🚚 Включена доставка до РФ
                </div>
            `;

            resultEl.innerHTML = resultHTML;
            resultEl.classList.add('show');

            // Update stats
            this.gameState.updateStats('calcCount', this.gameState.stats.calcCount + 1);

            // Send to Telegram if available
            this.sendToTelegram({
                price,
                category,
                result: result.toFixed(2),
                commission: commission.toFixed(2)
            });

            Utils.showNotification("✅ Расчёт выполнен!", 'success');

        } catch (error) {
            console.error('Calculation error:', error);
            Utils.showNotification("❌ Ошибка расчёта!", 'error');
        } finally {
            btn.classList.remove('loading');
            btn.disabled = false;
        }
    }

    sendToTelegram(data) {
        try {
            if (window.Telegram && window.Telegram.WebApp) {
                window.Telegram.WebApp.sendData(JSON.stringify(data));
            }
        } catch (e) {
            console.warn('Telegram WebApp not available:', e);
        }
    }
}

// ====================
// Miner Game Module
// ====================
class MinerGame {
    constructor(gameState) {
        this.gameState = gameState;
        this.grid = [];
        this.mines = [];
        this.gameOver = false;
        this.gameWon = false;
        this.step = 0;
        this.currentPrize = 0;
        this.stake = 0;
        this.minesCount = 5;
        this.gridSize = 5;
        this.multiplierTables = {
            3: [1.07, 1.23, 1.41, 1.62, 1.86, 2.13, 2.44, 2.78, 3.16, 3.58],
            4: [1.12, 1.32, 1.55, 1.82, 2.12, 2.46, 2.84, 3.27, 3.75, 4.29],
            5: [1.18, 1.42, 1.71, 2.05, 2.45, 2.92, 3.46, 4.08, 4.79, 5.60],
            6: [1.25, 1.53, 1.87, 2.28, 2.78, 3.37, 4.08, 4.91, 5.89, 7.03],
            7: [1.33, 1.66, 2.05, 2.52, 3.09, 3.78, 4.61, 5.61, 6.80, 8.23],
            8: [1.42, 1.82, 2.30, 2.87, 3.56, 4.41, 5.44, 6.69, 8.18, 9.95],
            9: [1.52, 1.99, 2.55, 3.24, 4.11, 5.20, 6.56, 8.27, 10.42, 13.12],
            10: [1.80, 2.30, 3.00, 3.90, 5.00, 6.40, 8.20, 10.50, 13.40, 17.00]
        };
        this.init();
    }

    init() {
        document.getElementById('startMinerGame').addEventListener('click', () => this.startGame());
        document.getElementById('takePrize').addEventListener('click', () => this.takePrize());

        const stakeInput = document.getElementById('minerStake');
        stakeInput.addEventListener('blur', (e) => {
            const value = parseInt(e.target.value);
            if (isNaN(value) || value < 1) {
                e.target.value = 1;
                Utils.showNotification("Минимальная ставка 1 монета", 'warning');
            }
            if (value > this.gameState.coins) {
                e.target.value = Math.floor(this.gameState.coins);
                Utils.showNotification(`Максимальная ставка ${Math.floor(this.gameState.coins)} монет`, 'warning');
            }
        });
    }

    startGame() {
        const stakeInput = document.getElementById('minerStake');
        const minesSelect = document.getElementById('numMines');

        this.stake = parseInt(stakeInput.value) || 1;
        this.minesCount = parseInt(minesSelect.value);

        if (this.stake < 1) {
            Utils.showNotification("Минимальная ставка 1 монета", 'warning');
            stakeInput.value = 1;
            return;
        }

        if (this.stake > this.gameState.coins) {
            Utils.showNotification("Недостаточно монет для ставки", 'error');
            stakeInput.value = Math.floor(this.gameState.coins);
            return;
        }

        // Deduct stake
        this.gameState.updateCoins(-this.stake);
        this.gameState.updateStats('minerGamesCount', this.gameState.stats.minerGamesCount + 1);

        this.resetGame();
        this.createGrid();
        this.placeMines();
        this.updateDisplay();

        Utils.showNotification("🎮 Игра началась! Удачи!", 'success');
    }

    resetGame() {
        this.grid = [];
        this.mines = [];
        this.gameOver = false;
        this.gameWon = false;
        this.step = 0;
        this.currentPrize = 0;

        document.getElementById('minerMsg').textContent = '';
        document.getElementById('takePrize').disabled = true;
    }

    createGrid() {
        const gridEl = document.getElementById('minerGrid');
        gridEl.innerHTML = '';

        for (let i = 0; i < this.gridSize * this.gridSize; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.index = i;

            const content = document.createElement('div');
            content.className = 'cell-content';
            content.textContent = '💣';
            cell.appendChild(content);

            cell.addEventListener('click', () => this.handleCellClick(i));

            gridEl.appendChild(cell);
            this.grid.push(cell);
        }
    }

    placeMines() {
        this.mines = [];
        while (this.mines.length < this.minesCount) {
            const index = Math.floor(Math.random() * this.gridSize * this.gridSize);
            if (!this.mines.includes(index)) {
                this.mines.push(index);
            }
        }
    }

    handleCellClick(index) {
        if (this.gameOver || this.grid[index].classList.contains('clicked')) {
            return;
        }

        const cell = this.grid[index];

        if (this.mines.includes(index)) {
            this.explodeGame(cell);
        } else {
            this.revealSafeCell(cell);
        }
    }

    explodeGame(clickedCell) {
        this.gameOver = true;
        clickedCell.classList.add('explode', 'mine');

        // Reveal all mines with delay
        this.mines.forEach((mineIndex, i) => {
            setTimeout(() => {
                const mineCell = this.grid[mineIndex];
                if (mineCell !== clickedCell) {
                    mineCell.classList.add('mine');
                    mineCell.querySelector('.cell-content').style.display = 'block';
                }
            }, i * 100);
        });

        document.getElementById('minerMsg').textContent = '💥 Вы взорвались! Игра окончена.';
        document.getElementById('takePrize').disabled = true;

        Utils.showNotification("💥 Бум! Попробуйте ещё раз!", 'error');
    }

    revealSafeCell(cell) {
        cell.classList.add('clicked');
        cell.querySelector('.cell-content').textContent = '💎';
        cell.querySelector('.cell-content').style.display = 'block';
        this.step++;

        const multiplier = this.calculateMultiplier(this.step, this.minesCount);
        this.currentPrize = this.stake * multiplier;

        this.updateDisplay();

        // Enable take prize button
        document.getElementById('takePrize').disabled = false;

        // Check win condition
        const safeCells = this.gridSize * this.gridSize - this.minesCount;
        if (this.step >= safeCells) {
            this.winGame();
        }
    }

    calculateMultiplier(step, minesCount) {
        const table = this.multiplierTables[minesCount];
        if (table && step > 0) {
            const index = Math.min(step - 1, table.length - 1);
            return table[index];
        }
        return 1.0;
    }

    winGame() {
        this.gameOver = true;
        this.gameWon = true;

        document.getElementById('minerMsg').textContent = `🎉 Поздравляем! Вы нашли все безопасные клетки!`;
        Utils.showNotification("🎉 Невероятно! Все клетки открыты!", 'success');
    }

    takePrize() {
        if (this.gameOver && !this.gameWon) return;

        this.gameState.updateCoins(this.currentPrize);

        // Update stats
        this.gameState.updateStats('minerWins', this.gameState.stats.minerWins + 1);
        if (this.currentPrize > this.gameState.stats.minerBestPrize) {
            this.gameState.updateStats('minerBestPrize', this.currentPrize);
        }

        document.getElementById('minerMsg').textContent =
            `💰 Вы забрали ${this.currentPrize.toFixed(1)} монет! Отличная игра!`;

        this.gameOver = true;
        document.getElementById('takePrize').disabled = true;

        Utils.showNotification(`💰 Приз ${this.currentPrize.toFixed(1)} монет получен!`, 'success');
    }

    updateDisplay() {
        const multiplier = this.calculateMultiplier(this.step, this.minesCount);
        const prize = this.stake * multiplier;

        document.getElementById('multiplier').textContent = `Множитель: ${multiplier.toFixed(2)}x`;
        document.getElementById('currentPrize').textContent = `Приз: ${prize.toFixed(1)} монет`;
    }
}

// ====================
// Run Game Module (ИСПРАВЛЕН)
// ====================
class RunGame {
    constructor(gameState) {
        this.gameState = gameState;
        this.canvas = document.getElementById('runCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.scoreEl = document.getElementById('runScore');

        // Game state
        this.playing = false;
        this.paused = false;
        this.animationId = null;
        this.lastTime = 0;

        // Game objects
        this.dino = {
            x: 30,
            y: 0,
            width: 40,
            height: 35,
            velocityY: 0,
            onGround: true,
            color: '#2563eb',
            animFrame: 0,
            animSpeed: 0.2
        };

        this.obstacles = [];
        this.coins = [];
        this.clouds = [];
        this.particles = [];
        this.stars = [];

        // Game parameters
        this.speed = 3;
        this.gravity = 0.7;
        this.jumpPower = -12;
        this.score = 0;
        this.coinCount = 0;
        this.lastObstacleSpawn = 0;
        this.groundY = this.canvas.height - 40;

        // Visual effects
        this.parallaxOffset = 0;
        this.timeOfDay = 0;

        this.init();
        this.createStars();
        this.resetGame();
    }

    init() {
        document.getElementById('restartRunBtn').addEventListener('click', () => this.startGame());
        document.getElementById('tapBtn').addEventListener('click', () => this.jump());

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                this.jump();
            }
            if (e.code === 'Enter') {
                this.startGame();
            }
        });

        // Touch controls
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.jump();
        }, { passive: false });

        // Mouse controls
        this.canvas.addEventListener('click', () => this.jump());
    }

    createStars() {
        this.stars = [];
        for (let i = 0; i < 80; i++) {
            this.stars.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height * 0.6,
                size: Math.random() * 2 + 0.5,
                twinkle: Math.random() * Math.PI * 2,
                twinkleSpeed: 0.02 + Math.random() * 0.03
            });
        }
    }

    startGame() {
        this.resetGame();
        this.playing = true;
        this.paused = false;
        this.lastTime = performance.now();

        this.gameState.updateStats('runGamesCount', this.gameState.stats.runGamesCount + 1);

        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }

        this.gameLoop(this.lastTime);
        Utils.showNotification("🏃 Беги и собирай монеты!", 'success');
    }

    resetGame() {
        this.dino.x = 30;
        this.dino.y = this.groundY - this.dino.height;
        this.dino.velocityY = 0;
        this.dino.onGround = true;
        this.dino.animFrame = 0;

        this.obstacles = [];
        this.coins = [];
        this.clouds = [];
        this.particles = [];

        this.speed = 3;
        this.score = 0;
        this.coinCount = 0;
        this.lastObstacleSpawn = 0;
        this.parallaxOffset = 0;
        this.timeOfDay = 0;

        this.updateScore();
    }

    gameLoop(currentTime) {
        if (!this.playing) return;

        const deltaTime = Math.min(currentTime - this.lastTime, 50);  // Cap at 50ms
        this.lastTime = currentTime;

        if (deltaTime > 0) {
            this.update(deltaTime);
            this.draw();
        }

        this.animationId = requestAnimationFrame((time) => this.gameLoop(time));
    }

    update(deltaTime) {
        const dt = deltaTime / 16.67;

        // Update time of day
        this.timeOfDay = Math.sin(this.score * 0.001) * 0.5 + 0.5;

        // Update dino animation
        this.dino.animFrame += this.dino.animSpeed * dt;

        // Update dino physics
        this.updateDino(dt);

        // Update game objects
        this.updateObstacles(dt);
        this.updateCoins(dt);
        this.updateClouds(dt);
        this.updateParticles(dt);

        // Update parallax
        this.parallaxOffset += this.speed * dt * 0.5;

        // Spawn new objects
        this.spawnObjects(deltaTime);

        // Update game parameters
        this.speed += 0.002 * dt;
        this.score += 0.02 * this.speed * dt;

        // Check collisions
        this.checkCollisions();

        this.updateScore();
    }

    updateDino(dt) {
        // Apply gravity
        if (!this.dino.onGround) {
            this.dino.velocityY += this.gravity * dt;
        }

        // Update position
        this.dino.y += this.dino.velocityY * dt;

        // Ground collision
        if (this.dino.y >= this.groundY - this.dino.height) {
            this.dino.y = this.groundY - this.dino.height;
            this.dino.velocityY = 0;
            this.dino.onGround = true;
        }
    }

    updateObstacles(dt) {
        this.obstacles.forEach(obstacle => {
            obstacle.x -= this.speed * dt;
            obstacle.sway += 0.05 * dt;
        });

        this.obstacles = this.obstacles.filter(obstacle => obstacle.x + obstacle.width > -10);
    }

    updateCoins(dt) {
        this.coins.forEach(coin => {
            if (!coin.collected) {
                coin.x -= this.speed * dt;
                coin.rotation += 0.12 * dt;
                coin.bob += 0.08 * dt;
                coin.y = coin.baseY + Math.sin(coin.bob) * 6;
            } else {
                coin.y += coin.velocityY * dt;
                coin.scale *= 0.95;
                coin.alpha *= 0.9;
                coin.velocityY += 0.5 * dt;
            }
        });

        this.coins = this.coins.filter(coin =>
            (coin.x + coin.width > -10 && !coin.collected) ||
            (coin.collected && coin.alpha > 0.01)
        );
    }

    updateClouds(dt) {
        this.clouds.forEach(cloud => {
            cloud.x -= cloud.speed * dt;
            cloud.drift += 0.02 * dt;
            cloud.y = cloud.baseY + Math.sin(cloud.drift) * 4;
        });

        this.clouds = this.clouds.filter(cloud => cloud.x + cloud.width > 0);
    }

    updateParticles(dt) {
        this.particles.forEach(particle => {
            particle.x += particle.velocityX * dt;
            particle.y += particle.velocityY * dt;
            particle.velocityY += particle.gravity * dt;
            particle.alpha *= 0.97;
            particle.scale *= 0.98;
            particle.rotation += particle.rotationSpeed * dt;
        });

        this.particles = this.particles.filter(particle => particle.alpha > 0.01);
    }

    spawnObjects(deltaTime) {
        this.lastObstacleSpawn += deltaTime;

        const spawnInterval = Math.max(1200 - this.speed * 30, 600);
        if (this.lastObstacleSpawn > spawnInterval) {
            this.spawnObstacle();
            this.lastObstacleSpawn = 0;
        }

        if (Math.random() < 0.003) {
            this.spawnCloud();
        }
    }

    spawnObstacle() {
        const height = 18 + Math.random() * 20;
        const width = 12 + Math.random() * 8;

        const obstacle = {
            x: this.canvas.width + 10,
            y: this.groundY,
            width: width,
            height: height,
            color: '#2e7d32',
            type: Math.random() > 0.5 ? 'cactus' : 'rock',
            sway: 0
        };

        this.obstacles.push(obstacle);

        if (Math.random() < 0.5) {
            this.spawnCoin(obstacle.x + 25, obstacle.y - obstacle.height - 50);
        }
    }

    spawnCoin(x, y) {
        const coin = {
            x: x || this.canvas.width + 10,
            y: y || this.groundY - 80 - Math.random() * 100,
            baseY: y || this.groundY - 80 - Math.random() * 100,
            width: 24,
            height: 24,
            collected: false,
            rotation: 0,
            bob: 0,
            scale: 1,
            alpha: 1,
            velocityY: 0,
            glow: 0
        };

        this.coins.push(coin);
    }

    spawnCloud() {
        const cloud = {
            x: this.canvas.width,
            y: 25 + Math.random() * 120,
            baseY: 25 + Math.random() * 120,
            width: 60 + Math.random() * 100,
            height: 30 + Math.random() * 50,
            speed: 0.6 + Math.random() * 1.5,
            alpha: 0.3 + Math.random() * 0.4,
            drift: 0
        };

        this.clouds.push(cloud);
    }

    checkCollisions() {
        // Check obstacle collisions
        for (let obstacle of this.obstacles) {
            if (this.dino.x < obstacle.x + obstacle.width - 4 &&
                this.dino.x + this.dino.width > obstacle.x + 4 &&
                this.dino.y < obstacle.y &&
                this.dino.y + this.dino.height > obstacle.y - obstacle.height + 4) {
                this.gameOver();
                return;
            }
        }

        // Check coin collisions
        for (let coin of this.coins) {
            if (!coin.collected &&
                this.dino.x < coin.x + coin.width - 4 &&
                this.dino.x + this.dino.width > coin.x + 4 &&
                this.dino.y < coin.y + coin.height - 4 &&
                this.dino.y + this.dino.height > coin.y + 4) {

                this.collectCoin(coin);
            }
        }
    }

    collectCoin(coin) {
        coin.collected = true;
        coin.velocityY = -3;

        this.coinCount += 0.5;
        this.gameState.updateCoins(0.5);
        this.gameState.updateStats('runCoinsCollected', this.gameState.stats.runCoinsCollected + 0.5);

        this.createCoinParticles(coin.x + coin.width / 2, coin.y + coin.height / 2);
    }

    createCoinParticles(x, y) {
        for (let i = 0; i < 10; i++) {
            this.particles.push({
                x: x,
                y: y,
                velocityX: (Math.random() - 0.5) * 8,
                velocityY: -Math.random() * 6 - 2,
                gravity: 0.3,
                alpha: 1,
                scale: 0.5 + Math.random() * 0.6,
                color: ['#fbbf24', '#f59e0b', '#d97706'][Math.floor(Math.random() * 3)],
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.2
            });
        }
    }

    jump() {
        if (this.dino.onGround && this.playing) {
            this.dino.velocityY = this.jumpPower;
            this.dino.onGround = false;

            // Jump particles
            for (let i = 0; i < 5; i++) {
                this.particles.push({
                    x: this.dino.x + this.dino.width / 2,
                    y: this.dino.y + this.dino.height,
                    velocityX: (Math.random() - 0.5) * 4,
                    velocityY: Math.random() * 2,
                    gravity: 0.15,
                    alpha: 0.7,
                    scale: 0.3 + Math.random() * 0.3,
                    color: '#8b5a3c',
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.1
                });
            }
        }
    }

    gameOver() {
        this.playing = false;

        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }

        if (this.score > this.gameState.stats.bestScore) {
            this.gameState.updateStats('bestScore', this.score);
            Utils.showNotification(`🏆 Новый рекорд: ${Math.floor(this.score)}!`, 'success');
        } else {
            Utils.showNotification(`💀 Игра окончена! Счёт: ${Math.floor(this.score)}`, 'error');
        }

        this.updateScore();
    }

    draw() {
        // Clear canvas
        this.ctx.fillStyle = '#87ceeb';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw ground
        this.ctx.fillStyle = '#8b5a3c';
        this.ctx.fillRect(0, this.groundY, this.canvas.width, this.canvas.height - this.groundY);

        // Ground line
        this.ctx.strokeStyle = '#5d4037';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.groundY);
        for (let x = 0; x < this.canvas.width; x += 4) {
            this.ctx.lineTo(x, this.groundY + Math.sin((x + this.parallaxOffset) * 0.05) * 1);
        }
        this.ctx.stroke();

        // Draw clouds
        this.drawClouds();

        // Draw dino
        this.drawDino();

        // Draw obstacles
        this.drawObstacles();

        // Draw coins
        this.drawCoins();

        // Draw particles
        this.drawParticles();

        // Draw UI
        this.drawUI();
    }

    drawClouds() {
        this.ctx.save();
        this.clouds.forEach(cloud => {
            this.ctx.globalAlpha = cloud.alpha;
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.ellipse(cloud.x, cloud.y, cloud.width / 2, cloud.height / 2, 0, 0, Math.PI * 2);
            this.ctx.fill();
        });
        this.ctx.restore();
    }

    drawDino() {
        this.ctx.save();

        // Shadow
        this.ctx.globalAlpha = 0.3;
        this.ctx.fillStyle = '#000000';
        this.ctx.ellipse(this.dino.x + this.dino.width / 2, this.groundY, this.dino.width / 2, 6, 0, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.restore();

        // Dino body
        this.ctx.fillStyle = this.dino.color;
        const bounce = this.dino.onGround ? Math.sin(this.dino.animFrame) * 1 : 0;
        this.ctx.fillRect(this.dino.x, this.dino.y + bounce, this.dino.width, this.dino.height);

        // Eyes
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillRect(this.dino.x + 25, this.dino.y + 6 + bounce, 4, 4);
        this.ctx.fillRect(this.dino.x + 32, this.dino.y + 6 + bounce, 4, 4);

        // Pupils
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(this.dino.x + 26, this.dino.y + 7 + bounce, 2, 2);
        this.ctx.fillRect(this.dino.x + 33, this.dino.y + 7 + bounce, 2, 2);
    }

    drawObstacles() {
        this.obstacles.forEach(obstacle => {
            this.ctx.save();

            // Shadow
            this.ctx.globalAlpha = 0.3;
            this.ctx.fillStyle = '#000000';
            this.ctx.fillRect(obstacle.x + 1, this.groundY + 1, obstacle.width, 3);

            this.ctx.restore();

            if (obstacle.type === 'cactus') {
                this.ctx.fillStyle = '#2e7d32';
                const swayOffset = Math.sin(obstacle.sway) * 1;
                this.ctx.fillRect(obstacle.x + swayOffset, obstacle.y - obstacle.height, obstacle.width, obstacle.height);

                // Spikes
                this.ctx.fillStyle = '#1b5e20';
                for (let i = 0; i < 2; i++) {
                    const spikeY = obstacle.y - obstacle.height * 0.3 - i * 6;
                    this.ctx.beginPath();
                    this.ctx.moveTo(obstacle.x + swayOffset - 1, spikeY);
                    this.ctx.lineTo(obstacle.x + swayOffset - 3, spikeY - 2);
                    this.ctx.lineTo(obstacle.x + swayOffset - 1, spikeY - 4);
                    this.ctx.fill();
                }
            } else {
                // Rock
                this.ctx.fillStyle = '#5d4037';
                this.ctx.beginPath();
                this.ctx.ellipse(obstacle.x + obstacle.width / 2, obstacle.y - obstacle.height / 2,
                                obstacle.width / 2, obstacle.height / 2, 0, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });
    }

    drawCoins() {
        this.coins.forEach(coin => {
            this.ctx.save();

            this.ctx.globalAlpha = coin.alpha;
            this.ctx.translate(coin.x + coin.width / 2, coin.y + coin.height / 2);
            this.ctx.rotate(coin.rotation);
            this.ctx.scale(coin.scale, coin.scale);

            // Coin gradient
            const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, coin.width / 2);
            gradient.addColorStop(0, '#fde047');
            gradient.addColorStop(0.7, '#fbbf24');
            gradient.addColorStop(1, '#f59e0b');

            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, coin.width / 2, 0, Math.PI * 2);
            this.ctx.fill();

            // Inner circle
            this.ctx.fillStyle = '#d97706';
            this.ctx.beginPath();
            this.ctx.arc(0, 0, coin.width / 3, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.restore();
        });
    }

    drawParticles() {
        this.particles.forEach(particle => {
            this.ctx.save();
            this.ctx.globalAlpha = particle.alpha;
            this.ctx.fillStyle = particle.color;
            this.ctx.translate(particle.x, particle.y);
            this.ctx.rotate(particle.rotation);
            this.ctx.scale(particle.scale, particle.scale);
            this.ctx.beginPath();
            this.ctx.arc(0, 0, 2, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        });
    }

    drawUI() {
        // Speed indicator
        this.ctx.save();
        this.ctx.fillStyle = 'rgba(100, 100, 255, 0.8)';
        this.ctx.fillRect(10, 10, 100, 25);
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.strokeRect(10, 10, 100, 25);

        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = 'bold 12px Arial';
        this.ctx.fillText(`⚡ ${this.speed.toFixed(1)} км/ч`, 15, 27);

        // Coins indicator
        this.ctx.fillStyle = 'rgba(255, 150, 0, 0.8)';
        this.ctx.fillRect(120, 10, 80, 25);
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.strokeRect(120, 10, 80, 25);

        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillText(`🪙 ${this.coinCount.toFixed(1)}`, 125, 27);

        this.ctx.restore();
    }

    updateScore() {
        const high = Math.floor(this.gameState.stats.bestScore);
        const current = Math.floor(this.score);
        this.scoreEl.textContent = `Счёт: ${current} • 🏆 Рекорд: ${high}`;
    }
}

// ====================
// Roulette Game Module (ИСПРАВЛЕН - МИНИМАЛЬНАЯ СТАВКА 1 МОНЕТА)
// ====================
class RouletteGame {
    constructor(gameState) {
        this.gameState = gameState;
        this.gameActive = false;
        this.currentStake = 0;
        this.selectedColor = null;
        this.spinning = false;
        this.colors = ['red', 'black', 'green'];
        this.multipliers = {
            red: 2.0,
            black: 2.0,
            green: 14.0
        };
        this.weights = {
            red: 45,    // 45% шанс
            black: 45,  // 45% шанс
            green: 10   // 10% шанс
        };
        this.init();
    }

    init() {
        document.getElementById('spinRoulette').addEventListener('click', () => this.spin());

        // Color selection
        document.querySelectorAll('.bet-option').forEach(option => {
            option.addEventListener('click', (e) => {
                document.querySelectorAll('.bet-option').forEach(opt => opt.classList.remove('selected'));
                e.target.classList.add('selected');
                this.selectedColor = e.target.dataset.color;
            });
        });

        // ИСПРАВЛЕНО: Минимальная ставка теперь 1 монета
        const stakeInput = document.getElementById('rouletteStake');
        stakeInput.addEventListener('blur', (e) => {
            const value = parseInt(e.target.value);
            if (isNaN(value) || value < 1) {
                e.target.value = 1;
                Utils.showNotification("Минимальная ставка 1 монета", 'warning');
            }
            if (value > this.gameState.coins) {
                e.target.value = Math.floor(this.gameState.coins);
                Utils.showNotification(`Максимальная ставка ${Math.floor(this.gameState.coins)} монет`, 'warning');
            }
        });
    }

    spin() {
        if (this.spinning) return;

        const stakeInput = document.getElementById('rouletteStake');
        this.currentStake = parseInt(stakeInput.value) || 1;

        if (!this.selectedColor) {
            Utils.showNotification("Выберите цвет для ставки!", 'warning');
            return;
        }

        if (this.currentStake < 1) {
            Utils.showNotification("Минимальная ставка 1 монета", 'warning');
            stakeInput.value = 1;
            return;
        }

        if (this.currentStake > this.gameState.coins) {
            Utils.showNotification("Недостаточно монет для ставки", 'error');
            stakeInput.value = Math.floor(this.gameState.coins);
            return;
        }

        // Deduct stake
        this.gameState.updateCoins(-this.currentStake);
        this.gameState.updateStats('rouletteGamesCount', this.gameState.stats.rouletteGamesCount + 1);

        this.spinning = true;
        document.getElementById('spinRoulette').disabled = true;

        const wheel = document.getElementById('rouletteWheel');
        const resultEl = document.getElementById('rouletteResult');
        const msgEl = document.getElementById('rouletteMsg');

        resultEl.style.display = 'none';
        msgEl.textContent = '🎰 Крутим рулетку...';

        // Generate result based on weights
        const result = this.getWeightedRandomColor();

        // Calculate spins (3-5 full rotations + final position)
        const baseSpins = 3 + Math.random() * 2;
        const finalPosition = this.getColorPosition(result);
        const totalRotation = (baseSpins * 360) + finalPosition;

        wheel.style.transform = `rotate(${totalRotation}deg)`;

        // Show result after animation
        setTimeout(() => {
            this.showResult(result);
        }, 3000);

        Utils.showNotification(`🎰 Рулетка крутится! Ставка на ${this.getColorName(this.selectedColor)}`, 'success');
    }

    getWeightedRandomColor() {
        const rand = Math.random() * 100;
        let cumulative = 0;

        for (const [color, weight] of Object.entries(this.weights)) {
            cumulative += weight;
            if (rand <= cumulative) {
                return color;
            }
        }

        return 'red'; // fallback
    }

    getColorPosition(color) {
        // Approximate positions on the wheel
        const positions = {
            red: 18,    // Middle of red section
            black: 54,  // Middle of black section
            green: 353  // Middle of green section
        };
        return positions[color] + (Math.random() - 0.5) * 20; // Add some randomness
    }

    getColorName(color) {
        const names = {
            red: 'красное',
            black: 'черное',
            green: 'зеленое'
        };
        return names[color];
    }

    showResult(result) {
        const resultEl = document.getElementById('rouletteResult');
        const msgEl = document.getElementById('rouletteMsg');

        this.spinning = false;
        document.getElementById('spinRoulette').disabled = false;

        if (result === this.selectedColor) {
            // WIN!
            const winAmount = this.currentStake * this.multipliers[result];
            this.gameState.updateCoins(winAmount);
            this.gameState.updateStats('rouletteWins', this.gameState.stats.rouletteWins + 1);

            if (winAmount > this.gameState.stats.rouletteBestWin) {
                this.gameState.updateStats('rouletteBestWin', winAmount);
            }

            resultEl.className = 'roulette-result win';
            resultEl.innerHTML = `🎉 ПОБЕДА!<br>Выпало: ${this.getColorName(result)}<br>Выигрыш: ${winAmount.toFixed(1)} монет`;
            resultEl.style.display = 'block';

            msgEl.textContent = `💰 Поздравляем! Вы выиграли ${winAmount.toFixed(1)} монет!`;

            Utils.showNotification(`🎉 Победа! Выигрыш ${winAmount.toFixed(1)} монет!`, 'success');
        } else {
            // LOSE
            resultEl.className = 'roulette-result lose';
            resultEl.innerHTML = `💥 Проигрыш!<br>Выпало: ${this.getColorName(result)}<br>Ваша ставка: ${this.getColorName(this.selectedColor)}`;
            resultEl.style.display = 'block';

            msgEl.textContent = `😔 В следующий раз повезёт больше!`;

            Utils.showNotification(`💥 Выпало ${this.getColorName(result)}! Попробуйте ещё раз!`, 'error');
        }

        // Reset selection
        document.querySelectorAll('.bet-option').forEach(opt => opt.classList.remove('selected'));
        this.selectedColor = null;
    }
}

// ====================
// UI Manager
// ====================
class UIManager {
    constructor(gameState) {
        this.gameState = gameState;
        this.init();
    }

    init() {
        this.setupOverlayControls();
        this.setupKeyboardShortcuts();
        this.setupLoadingScreen();
    }

    setupOverlayControls() {
        const overlay = document.getElementById('overlay');

        // Open/close main overlay
        document.getElementById('openGame').onclick = () => {
            overlay.classList.add('show');
            this.showGameSelection();
        };

        document.getElementById('closeGame').onclick = () => {
            overlay.classList.remove('show');
        };

        // Game selection
        document.getElementById('selectMiner').onclick = () => {
            this.showMinerGame();
        };

        document.getElementById('selectRun').onclick = () => {
            this.showRunGame();
        };

        document.getElementById('selectRoulette').onclick = () => {
            this.showRouletteGame();
        };

        // Game close buttons
        document.getElementById('closeMiner').onclick = () => {
            this.showGameSelection();
        };

        document.getElementById('closeRun').onclick = () => {
            this.showGameSelection();
        );
            this.showGameSelection();
        };

        // Click outside to close
        overlay.onclick = (e) => {
            if (e.target === overlay) {
                overlay.classList.remove('show');
            }
        };
    }

    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                const overlay = document.getElementById('overlay');
                if (overlay.classList.contains('show')) {
                    overlay.classList.remove('show');
                }
            }
        });
    }

    setupLoadingScreen() {
        const loadingScreen = document.getElementById('loadingScreen');

        // Simulate loading
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
        }, 1500);
    }

    showGameSelection() {
        document.getElementById('gameSelectCard').style.display = 'flex';
        document.getElementById('minerCard').style.display = 'none';
        document.getElementById('runCard').style.display = 'none';
        document.getElementById('rouletteCard').style.display = 'none';
    }

    showMinerGame() {
        document.getElementById('gameSelectCard').style.display = 'none';
        document.getElementById('minerCard').style.display = 'flex';
        document.getElementById('runCard').style.display = 'none';
        document.getElementById('rouletteCard').style.display = 'none';
    }

    showRunGame() {
        document.getElementById('gameSelectCard').style.display = 'none';
        document.getElementById('minerCard').style.display = 'none';
        document.getElementById('runCard').style.display = 'flex';
        document.getElementById('rouletteCard').style.display = 'none';
    }

    showRouletteGame() {
        document.getElementById('gameSelectCard').style.display = 'none';
        document.getElementById('minerCard').style.display = 'none';
        document.getElementById('runCard').style.display = 'none';
        document.getElementById('rouletteCard').style.display = 'flex';
    }
}

// ====================
// Application Bootstrap
// ====================
class PoizonApp {
    constructor() {
        this.gameState = new GameState();
        this.calculator = new Calculator(this.gameState);
        this.minerGame = new MinerGame(this.gameState);
        this.runGame = new RunGame(this.gameState);
        this.rouletteGame = new RouletteGame(this.gameState);
        this.uiManager = new UIManager(this.gameState);

        this.init();
    }

    init() {
        // Initialize UI
        this.gameState.updateUI();

        // Setup Telegram WebApp
        this.setupTelegramWebApp();

        // Setup error handling
        this.setupErrorHandling();

        console.log('🎮 Poizon App initialized successfully!');
    }

    setupTelegramWebApp() {
        try {
            if (window.Telegram && window.Telegram.WebApp) {
                const tg = window.Telegram.WebApp;
                tg.ready();
                tg.expand();
            }
        } catch (e) {
            console.warn('Telegram WebApp not available:', e);
        }
    }

    setupErrorHandling() {
        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
            Utils.showNotification('Произошла ошибка. Перезагрузите страницу.', 'error');
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
            Utils.showNotification('Произошла ошибка. Попробуйте ещё раз.', 'error');
        });
    }
}

// ====================
// Initialize App
// ====================
document.addEventListener('DOMContentLoaded', () => {
    new PoizonApp();
});

// Export for debugging
if (typeof window !== 'undefined') {
    window.PoizonApp = PoizonApp;
    window.Utils = Utils;
}
    </script>
</body>
</html>
