<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Run Poizon — калькулятор + игры</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
:root {
    --tg-bg: #0a0c10;
    --tg-fg: #ffffff;
    --tg-accent: #00d4ff;
    --tg-accent-2: #7c3aed;
    --card-bg: #141821;
    --card-bg-light: #1a1f2e;
    --border: #2a3441;
    --border-light: #374151;
    --shadow: 0 10px 30px rgba(0,0,0,0.4);
    --shadow-hover: 0 20px 40px rgba(0,0,0,0.6);
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
    --gradient: linear-gradient(135deg, var(--tg-accent), var(--tg-accent-2));
    --gradient-2: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --gradient-3: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
}

* {
    box-sizing: border-box;
}

body {
    font-family: -apple-system, system-ui, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans";
    background: linear-gradient(135deg, var(--tg-bg) 0%, #0f1419 50%, #1a1f2e 100%);
    color: var(--tg-fg);
    margin: 0;
    padding: 16px 16px 90px;
    display: flex;
    justify-content: center;
    min-height: 100vh;
    overflow-x: hidden;
    position: relative;
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 20% 80%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(124, 58, 237, 0.1) 0%, transparent 50%);
    pointer-events: none;
    z-index: -1;
}

.wrap {
    width: 100%;
    max-width: 420px;
    position: relative;
}

.card {
    background: var(--card-bg);
    border-radius: 24px;
    padding: 28px;
    box-shadow: var(--shadow);
    text-align: center;
    position: relative;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
    border: 1px solid var(--border);
    backdrop-filter: blur(10px);
}

.card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: var(--gradient);
    opacity: 0.9;
    border-radius: 24px 24px 0 0;
}

.card::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: conic-gradient(from 0deg, transparent, rgba(0, 212, 255, 0.03), transparent);
    animation: cardRotate 20s linear infinite;
    z-index: -1;
}

@keyframes cardRotate {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.logo-title {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 28px;
    position: relative;
}

.logo-title img {
    width: 64px;
    height: 64px;
    border-radius: 18px;
    margin-bottom: 16px;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
    border: 2px solid rgba(0, 212, 255, 0.2);
}

.logo-title img:hover {
    transform: scale(1.1) rotate(8deg);
    box-shadow: 0 12px 35px rgba(0, 212, 255, 0.5);
}

.logo-title span {
    color: var(--tg-fg);
    font-weight: 900;
    font-size: 26px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
}

.calculator-form {
    margin-bottom: 28px;
}

label {
    display: block;
    margin: 20px 0 10px;
    font-weight: 700;
    text-align: left;
    font-size: 16px;
    color: var(--tg-fg);
    opacity: 0.95;
}

input, select {
    width: 100%;
    padding: 16px 18px;
    border: 2px solid var(--border);
    border-radius: 16px;
    background: var(--card-bg-light);
    color: var(--tg-fg);
    font-size: 16px;
    transition: all 0.3s ease;
    outline: none;
    backdrop-filter: blur(10px);
}

input:focus, select:focus {
    border-color: var(--tg-accent);
    box-shadow: 0 0 0 4px rgba(0, 212, 255, 0.15);
    transform: translateY(-2px);
    background: var(--card-bg);
}

input:hover, select:hover {
    border-color: var(--border-light);
    transform: translateY(-1px);
}

input::placeholder {
    color: rgba(255, 255, 255, 0.4);
}

.btn {
    width: 100%;
    padding: 18px;
    background: var(--gradient);
    border: none;
    color: white;
    font-size: 17px;
    font-weight: 800;
    border-radius: 16px;
    cursor: pointer;
    margin-top: 24px;
    position: relative;
    overflow: hidden;
    transition: all 0.4s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
}

.btn::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
    transform: rotate(45deg);
    transition: all 0.5s;
    opacity: 0;
}

.btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 15px 35px rgba(0, 212, 255, 0.4);
}

.btn:hover::before {
    animation: shimmer 0.6s ease;
}

@keyframes shimmer {
    0% { left: -100%; opacity: 0; }
    50% { opacity: 1; }
    100% { left: 100%; opacity: 0; }
}

.btn:active {
    transform: translateY(-1px);
}

.btn-loader {
    width: 22px;
    height: 22px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top: 2px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    display: none;
}

.btn.loading .btn-text {
    opacity: 0.7;
}

.btn.loading .btn-loader {
    display: block;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.muted {
    opacity: 0.7;
    font-size: 14px;
    margin-top: 16px;
    text-align: left;
    line-height: 1.5;
    color: var(--tg-fg);
}

#result {
    margin-top: 24px;
    font-size: 18px;
    font-weight: 700;
    white-space: pre-line;
    text-align: left;
    padding: 20px;
    background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(124, 58, 237, 0.1));
    border-radius: 16px;
    border-left: 4px solid var(--tg-accent);
    transition: all 0.4s ease;
    transform: translateY(15px);
    opacity: 0;
    color: var(--tg-fg);
    backdrop-filter: blur(10px);
    border: 1px solid var(--border);
}

#result.show {
    transform: translateY(0);
    opacity: 1;
}

.stats-section {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    margin-top: 24px;
    padding-top: 24px;
    border-top: 1px solid var(--border);
}

.stat-item {
    text-align: center;
    padding: 16px 12px;
    background: linear-gradient(135deg, rgba(0, 212, 255, 0.08), rgba(124, 58, 237, 0.08));
    border-radius: 14px;
    transition: all 0.4s ease;
    border: 1px solid var(--border);
    backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
}

.stat-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: var(--gradient);
    opacity: 0;
    transition: all 0.3s ease;
}

.stat-item:hover {
    background: linear-gradient(135deg, rgba(0, 212, 255, 0.15), rgba(124, 58, 237, 0.15));
    transform: translateY(-4px);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

.stat-item:hover::before {
    opacity: 1;
}

.stat-label {
    display: block;
    font-size: 13px;
    opacity: 0.8;
    margin-bottom: 6px;
    color: var(--tg-fg);
    font-weight: 600;
}

.stat-item span:last-child {
    font-weight: 900;
    font-size: 18px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

#mainCoinCounter {
    position: absolute;
    top: 20px;
    right: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 900;
    color: var(--tg-accent);
    background: linear-gradient(135deg, rgba(0, 212, 255, 0.15), rgba(124, 58, 237, 0.15));
    padding: 12px 16px;
    border-radius: 25px;
    transition: all 0.4s ease;
    border: 1px solid var(--border);
    backdrop-filter: blur(15px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
}

#mainCoinCounter:hover {
    transform: scale(1.05);
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3);
}

#mainCoinCounter img {
    width: 28px;
    height: 28px;
    animation: coinFloat 3s ease-in-out infinite;
    filter: drop-shadow(0 4px 8px rgba(0, 212, 255, 0.3));
}

@keyframes coinFloat {
    0%, 100% { transform: translateY(0px) rotate(0deg); }
    50% { transform: translateY(-4px) rotate(180deg); }
}

.playbar {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 16px 20px calc(env(safe-area-inset-bottom) + 16px);
    background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.4) 20%), var(--tg-bg);
    display: flex;
    justify-content: center;
    border-top: 1px solid var(--border);
    z-index: 10;
    backdrop-filter: blur(20px);
}

.play-btn {
    max-width: 420px;
    width: calc(100% - 40px);
    background: var(--gradient);
    color: #fff;
    border: none;
    border-radius: 20px;
    padding: 20px;
    font-size: 18px;
    font-weight: 900;
    box-shadow: var(--shadow);
    cursor: pointer;
    transition: all 0.4s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 14px;
    position: relative;
    overflow: hidden;
}

.play-btn::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
    transform: rotate(45deg);
    transition: all 0.5s;
    opacity: 0;
}

.play-btn:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-hover);
}

.play-btn:hover::before {
    animation: shimmer 0.6s ease;
}

.game-icon {
    font-size: 24px;
    animation: gameIconPulse 2.5s ease-in-out infinite;
}

@keyframes gameIconPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.3); }
}

.overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.7);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 50;
    backdrop-filter: blur(12px);
    animation: overlayFadeIn 0.4s ease;
}

.overlay.show {
    display: flex;
}

@keyframes overlayFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.game-card {
    width: 96vw;
    max-width: 500px;
    max-height: 90vh;
    background: var(--card-bg);
    border-radius: 24px;
    box-shadow: var(--shadow-hover);
    padding: 24px;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-y: auto;
    animation: gameCardSlideIn 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    border: 1px solid var(--border);
    backdrop-filter: blur(15px);
}

@keyframes gameCardSlideIn {
    from {
        opacity: 0;
        transform: translateY(40px) scale(0.9);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.game-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px 20px;
    width: 100%;
    border-bottom: 1px solid var(--border);
    margin-bottom: 24px;
}

.game-title {
    font-weight: 900;
    font-size: 20px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.close-btn {
    border: 2px solid var(--border);
    background: var(--card-bg-light);
    color: var(--tg-fg);
    padding: 10px 20px;
    border-radius: 14px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
}

.close-btn:hover {
    border-color: var(--danger);
    color: var(--danger);
    transform: scale(1.05);
    background: rgba(239, 68, 68, 0.1);
}

.games-grid {
    display: grid;
    gap: 20px;
    width: 100%;
}

.game-choice-btn {
    width: 100%;
    padding: 24px;
    font-size: 17px;
    font-weight: 800;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.4s ease;
    border: 2px solid var(--border);
    background: linear-gradient(135deg, var(--card-bg-light), var(--card-bg));
    color: var(--tg-fg);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    text-align: center;
    position: relative;
    overflow: hidden;
    backdrop-filter: blur(10px);
}

.game-choice-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: var(--gradient);
    opacity: 0;
    transition: all 0.3s ease;
}

.game-choice-btn:hover {
    transform: translateY(-5px);
    box-shadow: var(--shadow-hover);
    border-color: var(--tg-accent);
}

.game-choice-btn:hover::before {
    opacity: 1;
}

.game-emoji {
    font-size: 40px;
    margin-bottom: 8px;
    animation: gameEmojiFloat 3s ease-in-out infinite;
}

@keyframes gameEmojiFloat {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-6px); }
}

.game-name {
    font-size: 20px;
    font-weight: 900;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.game-desc {
    font-size: 14px;
    opacity: 0.8;
    font-weight: 600;
    color: var(--tg-fg);
}

.game-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    width: 100%;
    margin-bottom: 24px;
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.control-group label {
    font-size: 15px;
    font-weight: 700;
    margin: 0;
    text-align: center;
    color: var(--tg-fg);
}

.control-group input,
.control-group select {
    padding: 14px;
    font-size: 15px;
    border-radius: 12px;
}

.game-info {
    display: flex;
    justify-content: space-between;
    width: 100%;
    margin-bottom: 20px;
    padding: 16px;
    background: linear-gradient(135deg, rgba(0, 212, 255, 0.12), rgba(124, 58, 237, 0.12));
    border-radius: 16px;
    border: 1px solid var(--border);
    backdrop-filter: blur(10px);
}

.game-info div {
    font-weight: 800;
    font-size: 15px;
    color: var(--tg-fg);
}

.game-btn {
    padding: 16px 28px;
    border: none;
    border-radius: 14px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.4s ease;
    margin: 10px 0;
    min-width: 160px;
    font-size: 16px;
    position: relative;
    overflow: hidden;
}

.game-btn::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
    transform: rotate(45deg);
    transition: all 0.5s;
    opacity: 0;
}

.game-btn.primary {
    background: var(--gradient);
    color: white;
    box-shadow: 0 6px 20px rgba(0, 212, 255, 0.3);
}

.game-btn.success {
    background: linear-gradient(135deg, var(--success), #059669);
    color: white;
    box-shadow: 0 6px 20px rgba(16, 185, 129, 0.3);
}

.game-btn.secondary {
    background: var(--card-bg-light);
    border: 2px solid var(--border) !important;
    color: var(--tg-fg);
    backdrop-filter: blur(10px);
}

.game-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3);
}

.game-btn:hover::before {
    animation: shimmer 0.6s ease;
}

.game-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

#minerGrid {
    display: grid;
    grid-template-columns: repeat(5, 60px);
    grid-gap: 10px;
    margin: 20px 0;
    padding: 20px;
    background: linear-gradient(135deg, rgba(42, 47, 58, 0.4), rgba(30, 35, 48, 0.4));
    border-radius: 20px;
    border: 1px solid var(--border);
    backdrop-filter: blur(10px);
    box-shadow: inset 0 4px 12px rgba(0, 0, 0, 0.2);
}

.cell {
    width: 60px;
    height: 60px;
    background: linear-gradient(145deg, #4a5568, #2d3748);
    border-radius: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.4s ease;
    position: relative;
    border: 2px solid transparent;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.cell:hover {
    transform: scale(1.15);
    box-shadow: 0 8px 20px rgba(0, 212, 255, 0.3);
    border-color: var(--tg-accent);
}

.cell.clicked {
    background: linear-gradient(145deg, #10b981, #059669);
    border-color: var(--success);
    box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
}

.cell.mine {
    background: linear-gradient(145deg, #ef4444, #dc2626);
    border-color: var(--danger);
    box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
}

.cell img {
    width: 44px;
    height: 44px;
    display: none;
    pointer-events: none;
    filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.5));
}

.cell.explode img {
    display: block;
    animation: explode 1s forwards;
}

.cell.win img {
    display: block;
    animation: winPulse 0.6s ease;
}

@keyframes explode {
    0% { transform: scale(1) rotate(0deg); opacity: 1; }
    50% { transform: scale(1.8) rotate(180deg); opacity: 0.8; }
    100% { transform: scale(0.2) rotate(360deg); opacity: 0; }
}

@keyframes winPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.3); }
}

#minerMsg {
    margin: 16px 0;
    font-weight: 800;
    font-size: 17px;
    min-height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--tg-fg);
}

.miner-stats,
.run-stats {
    display: flex;
    justify-content: space-around;
    width: 100%;
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid var(--border);
}

.stat {
    text-align: center;
    font-size: 13px;
    opacity: 0.9;
    color: var(--tg-fg);
    font-weight: 600;
}

.stat span {
    display: block;
    font-weight: 900;
    font-size: 16px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-top: 6px;
}

#runCanvas {
    width: 100%;
    height: 280px;
    border: 2px solid var(--border);
    border-radius: 20px;
    background: linear-gradient(180deg, #4dd0e1 0%, #81c784 30%, #aed581 70%, #8bc34a 100%);
    margin-bottom: 16px;
    box-shadow: inset 0 4px 12px rgba(0,0,0,0.2), 0 8px 25px rgba(0, 0, 0, 0.3);
    position: relative;
    overflow: hidden;
}

#runCanvas::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 70% 20%, rgba(255, 255, 255, 0.2) 0%, transparent 50%);
    pointer-events: none;
}

.score {
    font-weight: 900;
    margin: 16px 0;
    text-align: center;
    font-size: 18px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.game-cta {
    display: flex;
    gap: 16px;
    margin: 20px 0;
    width: 100%;
}

.game-cta button {
    flex: 1;
    padding: 16px;
    border-radius: 14px;
    border: none;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.4s ease;
    font-size: 16px;
}

.primary {
    background: var(--gradient);
    color: #fff;
    box-shadow: 0 6px 20px rgba(0, 212, 255, 0.3);
}

.secondary {
    background: var(--card-bg-light);
    border: 2px solid var(--border) !important;
    color: var(--tg-fg);
    backdrop-filter: blur(10px);
}

.primary:hover,
.secondary:hover {
    transform: translateY(-3px);
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3);
}

#notificationBox {
    position: fixed;
    top: 24px;
    right: 24px;
    background: var(--card-bg);
    border-radius: 16px;
    padding: 20px 24px;
    box-shadow: var(--shadow-hover);
    font-weight: 700;
    z-index: 1000;
    transform: translateX(450px);
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    border-left: 4px solid var(--tg-accent);
    max-width: 320px;
    color: var(--tg-fg);
    border: 1px solid var(--border);
    backdrop-filter: blur(15px);
}

#notificationBox.show {
    transform: translateX(0);
}

#notificationBox.error {
    border-left-color: var(--danger);
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), var(--card-bg));
}

#notificationBox.success {
    border-left-color: var(--success);
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), var(--card-bg));
}

#notificationBox.warning {
    border-left-color: var(--warning);
    background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), var(--card-bg));
}

#loadingScreen {
    position: fixed;
    inset: 0;
    background: var(--tg-bg);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    opacity: 1;
    transition: opacity 0.6s ease;
}

#loadingScreen.hidden {
    opacity: 0;
    pointer-events: none;
}

.loading-content {
    text-align: center;
}

.loading-logo {
    width: 90px;
    height: 90px;
    border-radius: 24px;
    margin-bottom: 24px;
    animation: loadingBounce 2s ease-in-out infinite;
    box-shadow: 0 12px 35px rgba(0, 212, 255, 0.4);
    border: 3px solid rgba(0, 212, 255, 0.3);
}

@keyframes loadingBounce {
    0%, 100% { transform: translateY(0px) scale(1); }
    50% { transform: translateY(-25px) scale(1.1); }
}

.loading-text {
    font-size: 20px;
    font-weight: 800;
    margin-bottom: 24px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.loading-bar {
    width: 220px;
    height: 6px;
    background: var(--border);
    border-radius: 3px;
    overflow: hidden;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
}

.loading-progress {
    height: 100%;
    background: var(--gradient);
    width: 0%;
    animation: loadingProgress 2.5s ease-in-out infinite;
    border-radius: 3px;
}

@keyframes loadingProgress {
    0% { width: 0%; }
    50% { width: 80%; }
    100% { width: 100%; }
}

/* Game UI improvements */
.speed-indicator, .coins-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 16px;
    border-radius: 12px;
    font-weight: bold;
    font-size: 15px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.speed-indicator {
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    color: white;
}

.coins-indicator {
    background: linear-gradient(135deg, #f59e0b, #f97316);
    color: white;
}

.speed-icon, .coins-icon {
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
}

/* Responsive Design */
@media (max-width: 480px) {
    body {
        padding: 12px 12px 80px;
    }

    .card {
        padding: 24px;
        border-radius: 20px;
    }

    .logo-title img {
        width: 56px;
        height: 56px;
    }

    .logo-title span {
        font-size: 22px;
    }

    .stats-section {
        grid-template-columns: 1fr;
        gap: 12px;
    }

    .stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        text-align: left;
    }

    .stat-label {
        margin-bottom: 0;
    }

    .game-controls {
        grid-template-columns: 1fr;
    }

    #minerGrid {
        grid-template-columns: repeat(5, 52px);
        grid-gap: 8px;
    }

    .cell {
        width: 52px;
        height: 52px;
    }

    .cell img {
        width: 36px;
        height: 36px;
    }

    #runCanvas {
        height: 240px;
    }
}

/* Accessibility */
@media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* Focus styles for accessibility */
button:focus-visible,
input:focus-visible,
select:focus-visible {
    outline: 3px solid var(--tg-accent);
    outline-offset: 2px;
}

/* Print styles */
@media print {
    .playbar,
    .overlay,
    #notificationBox {
        display: none !important;
    }

    .card {
        box-shadow: none;
        border: 1px solid #ccc;
    }
}
    </style>
</head>
<body>
    <div class="wrap">
        <div class="card">
            <div id="mainCoinCounter">
                <img src="coins.png" alt="Монетки">
                <span id="mainCoins">10</span>
            </div>

            <div class="logo-title">
                <img src="poizon.png" alt="Poizon logo">
                <span>Калькулятор</span>
            </div>

            <div class="calculator-form">
                <label for="price">Цена в юанях</label>
                <input type="number" id="price" placeholder="Например, 500" inputmode="decimal"/>

                <label for="category">Категория</label>
                <select id="category">
                    <option value="Футболка / майка / рубашка">Футболка / майка / рубашка</option>
                    <option value="Брюки / джинсы">Брюки / джинсы</option>
                    <option value="Худи / толстовка / свитшот">Худи / толстовка / свитшот</option>
                    <option value="Сумка / рюкзак">Сумка / рюкзак</option>
                    <option value="Поясная сумка">Поясная сумка</option>
                    <option value="Шапка/ шарф / носки">Шапка/ шарф / носки</option>
                    <option value="Ветровка / куртка">Ветровка / куртка</option>
                    <option value="Кроссовки / кеды / ботинки">Кроссовки / кеды / ботинки</option>
                    <option value="Зимняя обувь">Зимняя обувь</option>
                </select>

                <button class="btn" id="calcBtn">
                    <span class="btn-text">Рассчитать</span>
                    <span class="btn-loader"></span>
                </button>

                <div id="result"></div>
                <div class="muted">После расчёта результат отправится в чат бота.</div>
            </div>

            <!-- Stats Section -->
            <div class="stats-section">
                <div class="stat-item">
                    <span class="stat-label">Расчётов:</span>
                    <span id="calcCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Игр сыграно:</span>
                    <span id="gamesPlayed">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Рекорд Run:</span>
                    <span id="bestScore">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Error/Success notifications -->
    <div id="notificationBox"></div>

    <!-- Game Button -->
    <div class="playbar">
        <button class="play-btn" id="openGame">
            <span class="game-icon">🎮</span>
            <span>Играть</span>
        </button>
    </div>

    <!-- Game Overlay -->
    <div class="overlay" id="overlay">
        <!-- Game Selection -->
        <div class="game-card" id="gameSelectCard">
            <div class="game-header">
                <div class="game-title">Выберите игру</div>
                <button class="close-btn" id="closeGame">Закрыть</button>
            </div>
            <div class="games-grid">
                <button class="game-choice-btn" id="selectMiner">
                    <span class="game-emoji">💣</span>
                    <span class="game-name">Poizon Miner</span>
                    <span class="game-desc">Найди алмазы, избегай мин</span>
                </button>
                <button class="game-choice-btn" id="selectRun">
                    <span class="game-emoji">🏃</span>
                    <span class="game-name">Run Poizon</span>
                    <span class="game-desc">Беги и собирай монеты</span>
                </button>
            </div>
        </div>

        <!-- Miner Game -->
        <div class="game-card" id="minerCard" style="display:none;">
            <div class="game-header">
                <div class="game-title">💣 Poizon Miner</div>
                <button class="close-btn" id="closeMiner">Закрыть</button>
            </div>

            <div id="minerBet" class="game-controls">
                <div class="control-group">
                    <label>Ставка (монеты)</label>
                    <input type="number" id="minerStake" min="10" placeholder="10" value="10">
                </div>
                <div class="control-group">
                    <label>Количество мин</label>
                    <select id="numMines">
                        <option value="3">3 мины (легко)</option>
                        <option value="4">4 мины</option>
                        <option value="5" selected>5 мины (норм)</option>
                        <option value="6">6 мины</option>
                        <option value="7">7 мины</option>
                        <option value="8">8 мины (сложно)</option>
                        <option value="9">9 мины</option>
                        <option value="10">10 мины (экстрим)</option>
                    </select>
                </div>
            </div>

            <div class="game-info">
                <div id="multiplier">Множитель: 0.0x</div>
                <div id="currentPrize">Приз: 0 монет</div>
            </div>

            <button class="game-btn primary" id="startMinerGame">Начать игру</button>
            <div id="minerGrid"></div>
            <button class="game-btn success" id="takePrize" disabled>Забрать приз</button>
            <div id="minerMsg"></div>

            <div class="miner-stats">
                <div class="stat">Игр: <span id="minerGamesCount">0</span></div>
                <div class="stat">Побед: <span id="minerWins">0</span></div>
                <div class="stat">Лучший приз: <span id="minerBestPrize">0</span></div>
            </div>
        </div>

        <!-- Run Game -->
        <div class="game-card" id="runCard" style="display:none;">
            <div class="game-header">
                <div class="game-title">🏃 Run Poizon</div>
                <button class="close-btn" id="closeRun">Закрыть</button>
            </div>

            <canvas id="runCanvas" width="480" height="280"></canvas>
            <div class="score" id="runScore"></div>

            <div class="game-cta">
                <button class="secondary" id="tapBtn">Прыжок</button>
                <button class="primary" id="restartRunBtn">Старт/Рестарт</button>
            </div>

            <div class="run-stats">
                <div class="stat">Игр: <span id="runGamesCount">0</span></div>
                <div class="stat">Монет собрано: <span id="runCoinsCollected">0</span></div>
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loading-content">
            <img src="poizon.png" alt="Loading" class="loading-logo">
            <div class="loading-text">Загрузка...</div>
            <div class="loading-bar">
                <div class="loading-progress"></div>
            </div>
        </div>
    </div>

    <script>
// ====================
// Global Variables & State Management
// ====================
class GameState {
    constructor() {
        this.coins = this.loadData('coins', 10);
        this.stats = this.loadData('stats', {
            calcCount: 0,
            gamesPlayed: 0,
            bestScore: 0,
            minerGamesCount: 0,
            minerWins: 0,
            minerBestPrize: 0,
            runGamesCount: 0,
            runCoinsCollected: 0
        });
        this.settings = this.loadData('settings', {
            animationsEnabled: true,
            soundEnabled: false
        });
    }

    loadData(key, defaultValue) {
        try {
            const saved = localStorage.getItem(`poizon_${key}`);
            return saved ? JSON.parse(saved) : defaultValue;
        } catch (e) {
            console.warn(`Failed to load ${key}:`, e);
            return defaultValue;
        }
    }

    saveData(key, value) {
        try {
            localStorage.setItem(`poizon_${key}`, JSON.stringify(value));
        } catch (e) {
            console.warn(`Failed to save ${key}:`, e);
        }
    }

    updateCoins(amount) {
        this.coins = Math.max(0, this.coins + amount);
        this.saveData('coins', this.coins);
        this.updateUI();
    }

    updateStats(key, value) {
        this.stats[key] = value;
        this.saveData('stats', this.stats);
        this.updateUI();
    }

    updateUI() {
        document.getElementById('mainCoins').textContent = this.coins.toFixed(1);
        document.getElementById('calcCount').textContent = this.stats.calcCount;
        document.getElementById('gamesPlayed').textContent = this.stats.gamesPlayed;
        document.getElementById('bestScore').textContent = Math.floor(this.stats.bestScore);

        // Update miner stats if elements exist
        const minerGamesEl = document.getElementById('minerGamesCount');
        if (minerGamesEl) minerGamesEl.textContent = this.stats.minerGamesCount;

        const minerWinsEl = document.getElementById('minerWins');
        if (minerWinsEl) minerWinsEl.textContent = this.stats.minerWins;

        const minerBestPrizeEl = document.getElementById('minerBestPrize');
        if (minerBestPrizeEl) minerBestPrizeEl.textContent = this.stats.minerBestPrize.toFixed(1);

        const runGamesEl = document.getElementById('runGamesCount');
        if (runGamesEl) runGamesEl.textContent = this.stats.runGamesCount;

        const runCoinsEl = document.getElementById('runCoinsCollected');
        if (runCoinsEl) runCoinsEl.textContent = this.stats.runCoinsCollected.toFixed(1);
    }
}

// ====================
// Utility Functions
// ====================
class Utils {
    static showNotification(message, type = 'info', duration = 3000) {
        const notificationBox = document.getElementById('notificationBox');
        notificationBox.textContent = message;
        notificationBox.className = `show ${type}`;

        setTimeout(() => {
            notificationBox.classList.remove('show');
        }, duration);
    }

    static formatNumber(num) {
        return new Intl.NumberFormat('ru-RU', {
            minimumFractionDigits: 0,
            maximumFractionDigits: 2
        }).format(num);
    }

    static generateId() {
        return Math.random().toString(36).substr(2, 9);
    }

    static clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }

    static lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    static randomBetween(min, max) {
        return Math.random() * (max - min) + min;
    }
}

// ====================
// Calculator Module
// ====================
class Calculator {
    constructor(gameState) {
        this.gameState = gameState;
        this.formulas = {
            "Футболка / майка / рубашка": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 772.31 + 1000,
            "Брюки / джинсы": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 1019.91 + 1000,
            "Худи / толстовка / свитшот": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 1081.81 + 1000,
            "Сумка / рюкзак": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 1453.21 + 1000,
            "Поясная сумка": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 772.31 + 1000,
            "Шапка/ шарф / носки": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 772.31 + 1000,
            "Ветровка / куртка": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 1453.21 + 1000,
            "Кроссовки / кеды / ботинки": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 1733.59 + 1000,
            "Зимняя обувь": x => (x + (x > 1526 ? x * 0.15 : 0)) * 12 + 2104.99 + 1000
        };
        this.init();
    }

    init() {
        document.getElementById('calcBtn').addEventListener('click', () => this.calculate());

        // Enter key support
        document.getElementById('price').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.calculate();
        });
    }

    async calculate() {
        const btn = document.getElementById('calcBtn');
        const resultEl = document.getElementById('result');
        const priceInput = document.getElementById('price');
        const categorySelect = document.getElementById('category');

        const price = parseFloat(priceInput.value);
        const category = categorySelect.value;

        if (isNaN(price) || price <= 0) {
            Utils.showNotification("⚠️ Введите корректную цену!", 'warning');
            priceInput.focus();
            return;
        }

        if (price > 1000000) {
            Utils.showNotification("⚠️ Цена слишком высокая!", 'warning');
            return;
        }

        // Loading state
        btn.classList.add('loading');
        btn.disabled = true;

        try {
            // Simulate calculation delay for better UX
            await new Promise(resolve => setTimeout(resolve, 800));

            const result = this.formulas[category](price);
            const commission = price > 1526 ? price * 0.15 : 0;

            const resultText = `💰 К оплате: ${Utils.formatNumber(result)} ₽
📦 Категория: ${category}
💸 Цена: ${Utils.formatNumber(price)} ¥
${commission > 0 ? `📊 Комиссия: ${Utils.formatNumber(commission)} ¥` : ''}`;

            resultEl.innerHTML = resultText;
            resultEl.classList.add('show');

            // Update stats
            this.gameState.updateStats('calcCount', this.gameState.stats.calcCount + 1);

            // Send to Telegram if available
            this.sendToTelegram({
                price,
                category,
                result: result.toFixed(2),
                commission: commission.toFixed(2)
            });

            Utils.showNotification("✅ Расчёт выполнен!", 'success');

        } catch (error) {
            console.error('Calculation error:', error);
            Utils.showNotification("❌ Ошибка расчёта!", 'error');
        } finally {
            btn.classList.remove('loading');
            btn.disabled = false;
        }
    }

    sendToTelegram(data) {
        try {
            if (window.Telegram && window.Telegram.WebApp) {
                window.Telegram.WebApp.sendData(JSON.stringify(data));
            }
        } catch (e) {
            console.warn('Telegram WebApp not available:', e);
        }
    }
}

// ====================
// Miner Game Module
// ====================
class MinerGame {
    constructor(gameState) {
        this.gameState = gameState;
        this.grid = [];
        this.mines = [];
        this.gameOver = false;
        this.gameWon = false;
        this.step = 0;
        this.currentPrize = 0;
        this.stake = 0;
        this.minesCount = 5;
        this.gridSize = 5;
        this.multiplierTables = {
            3: [1.07, 1.23, 1.41, 1.62, 1.86, 2.13, 2.44, 2.78, 3.16, 3.58],
            4: [1.12, 1.32, 1.55, 1.82, 2.12, 2.46, 2.84, 3.27, 3.75, 4.29],
            5: [1.18, 1.42, 1.71, 2.05, 2.45, 2.92, 3.46, 4.08, 4.79, 5.60],
            6: [1.25, 1.53, 1.87, 2.28, 2.78, 3.37, 4.08, 4.91, 5.89, 7.03],
            7: [1.33, 1.66, 2.05, 2.52, 3.09, 3.78, 4.61, 5.61, 6.80, 8.23],
            8: [1.42, 1.82, 2.30, 2.87, 3.56, 4.41, 5.44, 6.69, 8.18, 9.95],
            9: [1.52, 1.99, 2.55, 3.24, 4.11, 5.20, 6.56, 8.27, 10.42, 13.12],
            10: [1.80, 2.30, 3.00, 3.90, 5.00, 6.40, 8.20, 10.50, 13.40, 17.00]
        };
        this.init();
    }

    init() {
        document.getElementById('startMinerGame').addEventListener('click', () => this.startGame());
        document.getElementById('takePrize').addEventListener('click', () => this.takePrize());

        // ИСПРАВЛЕН БАГ: Убрана автокоррекция при вводе, валидация только при потере фокуса
        const stakeInput = document.getElementById('minerStake');
        stakeInput.addEventListener('blur', (e) => {
            const value = parseInt(e.target.value);
            if (isNaN(value) || value < 10) {
                e.target.value = 10;
                Utils.showNotification("Минимальная ставка 10 монет", 'warning');
            }
            if (value > this.gameState.coins) {
                e.target.value = Math.floor(this.gameState.coins);
                Utils.showNotification(`Максимальная ставка ${Math.floor(this.gameState.coins)} монет`, 'warning');
            }
        });
    }

    startGame() {
        const stakeInput = document.getElementById('minerStake');
        const minesSelect = document.getElementById('numMines');

        this.stake = parseInt(stakeInput.value) || 10;
        this.minesCount = parseInt(minesSelect.value);

        if (this.stake < 10) {
            Utils.showNotification("Минимальная ставка 10 монет", 'warning');
            stakeInput.value = 10;
            return;
        }

        if (this.stake > this.gameState.coins) {
            Utils.showNotification("Недостаточно монет для ставки", 'error');
            stakeInput.value = Math.floor(this.gameState.coins);
            return;
        }

        // Deduct stake
        this.gameState.updateCoins(-this.stake);
        this.gameState.updateStats('minerGamesCount', this.gameState.stats.minerGamesCount + 1);

        this.resetGame();
        this.createGrid();
        this.placeMines();
        this.updateDisplay();

        Utils.showNotification("🎮 Игра началась! Удачи!", 'success');
    }

    resetGame() {
        this.grid = [];
        this.mines = [];
        this.gameOver = false;
        this.gameWon = false;
        this.step = 0;
        this.currentPrize = 0;

        document.getElementById('minerMsg').textContent = '';
        document.getElementById('takePrize').disabled = true;
    }

    createGrid() {
        const gridEl = document.getElementById('minerGrid');
        gridEl.innerHTML = '';

        for (let i = 0; i < this.gridSize * this.gridSize; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.index = i;

            const img = document.createElement('img');
            img.src = 'mina.png';
            img.alt = 'Mine';
            cell.appendChild(img);

            cell.addEventListener('click', () => this.handleCellClick(i));

            gridEl.appendChild(cell);
            this.grid.push(cell);
        }
    }

    placeMines() {
        this.mines = [];
        while (this.mines.length < this.minesCount) {
            const index = Math.floor(Math.random() * this.gridSize * this.gridSize);
            if (!this.mines.includes(index)) {
                this.mines.push(index);
            }
        }
    }

    handleCellClick(index) {
        if (this.gameOver || this.grid[index].classList.contains('clicked')) {
            return;
        }

        const cell = this.grid[index];

        if (this.mines.includes(index)) {
            this.explodeGame(cell);
        } else {
            this.revealSafeCell(cell);
        }
    }

    explodeGame(clickedCell) {
        this.gameOver = true;
        clickedCell.classList.add('explode', 'mine');

        // Reveal all mines with delay
        this.mines.forEach((mineIndex, i) => {
            setTimeout(() => {
                const mineCell = this.grid[mineIndex];
                if (mineCell !== clickedCell) {
                    mineCell.classList.add('mine');
                    mineCell.querySelector('img').style.display = 'block';
                }
            }, i * 100);
        });

        document.getElementById('minerMsg').textContent = '💥 Вы взорвались! Игра окончена.';
        document.getElementById('takePrize').disabled = true;

        Utils.showNotification("💥 Бум! Попробуйте ещё раз!", 'error');
    }

    revealSafeCell(cell) {
        cell.classList.add('clicked');
        this.step++;

        const multiplier = this.calculateMultiplier(this.step, this.minesCount);
        this.currentPrize = this.stake * multiplier;

        this.updateDisplay();

        // Enable take prize button
        document.getElementById('takePrize').disabled = false;

        // Check win condition
        const safeCells = this.gridSize * this.gridSize - this.minesCount;
        if (this.step >= safeCells) {
            this.winGame();
        }
    }

    calculateMultiplier(step, minesCount) {
        const table = this.multiplierTables[minesCount];
        if (table && step > 0) {
            const index = Math.min(step - 1, table.length - 1);
            return table[index];
        }
        return 1.0;
    }

    winGame() {
        this.gameOver = true;
        this.gameWon = true;

        document.getElementById('minerMsg').textContent = `🎉 Поздравляем! Вы нашли все безопасные клетки!`;
        Utils.showNotification("🎉 Невероятно! Все клетки открыты!", 'success');
    }

    takePrize() {
        if (this.gameOver && !this.gameWon) return;

        this.gameState.updateCoins(this.currentPrize);

        // Update stats
        this.gameState.updateStats('minerWins', this.gameState.stats.minerWins + 1);
        if (this.currentPrize > this.gameState.stats.minerBestPrize) {
            this.gameState.updateStats('minerBestPrize', this.currentPrize);
        }

        document.getElementById('minerMsg').textContent =
            `💰 Вы забрали ${this.currentPrize.toFixed(1)} монет! Отличная игра!`;

        this.gameOver = true;
        document.getElementById('takePrize').disabled = true;

        Utils.showNotification(`💰 Приз ${this.currentPrize.toFixed(1)} монет получен!`, 'success');
    }

    updateDisplay() {
        const multiplier = this.calculateMultiplier(this.step, this.minesCount);
        const prize = this.stake * multiplier;

        document.getElementById('multiplier').textContent = `Множитель: ${multiplier.toFixed(2)}x`;
        document.getElementById('currentPrize').textContent = `Приз: ${prize.toFixed(1)} монет`;
    }
}

// ====================
// Run Game Module (УЛУЧШЕННЫЙ ДИЗАЙН)
// ====================
class RunGame {
    constructor(gameState) {
        this.gameState = gameState;
        this.canvas = document.getElementById('runCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.scoreEl = document.getElementById('runScore');

        // Game state
        this.playing = false;
        this.paused = false;
        this.animationId = null;
        this.lastTime = 0;

        // Game objects
        this.dino = {
            x: 30,
            y: this.canvas.height - 100,
            width: 50,
            height: 40,
            velocityY: 0,
            onGround: true,
            color: '#2563eb',
            animFrame: 0,
            animSpeed: 0.2
        };

        this.obstacles = [];
        this.coins = [];
        this.clouds = [];
        this.particles = [];
        this.stars = [];

        // Game parameters
        this.speed = 4;
        this.gravity = 0.8;
        this.jumpPower = -12;
        this.score = 0;
        this.coinCount = 0;
        this.lastObstacleSpawn = 0;
        this.groundY = this.canvas.height - 50;

        // Visual effects
        this.parallaxOffset = 0;
        this.timeOfDay = 0; // 0 = day, 1 = night

        // Images
        this.images = {
            dino: null,
            coin: null,
            cloud: null,
            cactus: null
        };

        this.init();
        this.loadImages();
        this.createStars();
    }

    init() {
        document.getElementById('restartRunBtn').addEventListener('click', () => this.startGame());
        document.getElementById('tapBtn').addEventListener('click', () => this.jump());

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                this.jump();
            }
            if (e.code === 'Enter') {
                this.startGame();
            }
        });

        // Touch controls
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.jump();
        }, { passive: false });

        // Mouse controls
        this.canvas.addEventListener('click', () => this.jump());
    }

    loadImages() {
        const imageUrls = {
            dino: 'sticker.png',
            coin: 'coins.png',
            cloud: 'cloud.png'
        };

        Object.keys(imageUrls).forEach(key => {
            const img = new Image();
            img.onload = () => {
                this.images[key] = img;
            };
            img.onerror = () => {
                console.warn(`Failed to load image: ${imageUrls[key]}`);
                this.images[key] = null;
            };
            img.src = imageUrls[key];
        });
    }

    createStars() {
        this.stars = [];
        for (let i = 0; i < 100; i++) {
            this.stars.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height * 0.6,
                size: Math.random() * 2 + 0.5,
                twinkle: Math.random() * Math.PI * 2,
                twinkleSpeed: 0.02 + Math.random() * 0.03
            });
        }
    }

    startGame() {
        this.resetGame();
        this.playing = true;
        this.paused = false;
        this.lastTime = 0;

        this.gameState.updateStats('runGamesCount', this.gameState.stats.runGamesCount + 1);

        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }

        this.gameLoop(0);
        Utils.showNotification("🏃 Беги и собирай монеты!", 'success');
    }

    resetGame() {
        this.dino.x = 30;
        this.dino.y = this.groundY - this.dino.height;
        this.dino.velocityY = 0;
        this.dino.onGround = true;
        this.dino.animFrame = 0;

        this.obstacles = [];
        this.coins = [];
        this.clouds = [];
        this.particles = [];

        this.speed = 4;
        this.score = 0;
        this.coinCount = 0;
        this.lastObstacleSpawn = 0;
        this.parallaxOffset = 0;
        this.timeOfDay = 0;

        this.updateScore();
    }

    gameLoop(currentTime) {
        if (!this.playing) return;

        const deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;

        if (deltaTime < 100) {
            this.update(deltaTime);
            this.draw();
        }

        this.animationId = requestAnimationFrame((time) => this.gameLoop(time));
    }

    update(deltaTime) {
        const dt = deltaTime / 16.67;

        // Update time of day
        this.timeOfDay = Math.sin(this.score * 0.001) * 0.5 + 0.5;

        // Update dino animation
        this.dino.animFrame += this.dino.animSpeed * dt;

        // Update dino physics
        this.updateDino(dt);

        // Update game objects
        this.updateObstacles(dt);
        this.updateCoins(dt);
        this.updateClouds(dt);
        this.updateParticles(dt);

        // Update parallax
        this.parallaxOffset += this.speed * dt * 0.5;

        // Spawn new objects
        this.spawnObjects(deltaTime);

        // Update game parameters
        this.speed += 0.003 * dt;
        this.score += 0.025 * this.speed * dt;

        // Check collisions
        this.checkCollisions();

        this.updateScore();
    }

    updateDino(dt) {
        // Apply gravity
        if (!this.dino.onGround) {
            this.dino.velocityY += this.gravity * dt;
        }

        // Update position
        this.dino.y += this.dino.velocityY * dt;

        // Ground collision
        if (this.dino.y >= this.groundY - this.dino.height) {
            this.dino.y = this.groundY - this.dino.height;
            this.dino.velocityY = 0;
            this.dino.onGround = true;
        }
    }

    updateObstacles(dt) {
        this.obstacles.forEach(obstacle => {
            obstacle.x -= this.speed * dt;
            obstacle.sway += 0.05 * dt;
        });

        this.obstacles = this.obstacles.filter(obstacle => obstacle.x + obstacle.width > -10);
    }

    updateCoins(dt) {
        this.coins.forEach(coin => {
            if (!coin.collected) {
                coin.x -= this.speed * dt;
                coin.rotation += 0.12 * dt;
                coin.bob += 0.08 * dt;
                coin.y = coin.baseY + Math.sin(coin.bob) * 8;
            } else {
                coin.y += coin.velocityY * dt;
                coin.scale *= 0.94;
                coin.alpha *= 0.88;
                coin.velocityY += 0.6 * dt;
            }
        });

        this.coins = this.coins.filter(coin =>
            (coin.x + coin.width > -10 && !coin.collected) ||
            (coin.collected && coin.alpha > 0.01)
        );
    }

    updateClouds(dt) {
        this.clouds.forEach(cloud => {
            cloud.x -= cloud.speed * dt;
            cloud.drift += 0.02 * dt;
            cloud.y = cloud.baseY + Math.sin(cloud.drift) * 5;
        });

        this.clouds = this.clouds.filter(cloud => cloud.x + cloud.width > 0);
    }

    updateParticles(dt) {
        this.particles.forEach(particle => {
            particle.x += particle.velocityX * dt;
            particle.y += particle.velocityY * dt;
            particle.velocityY += particle.gravity * dt;
            particle.alpha *= 0.97;
            particle.scale *= 0.98;
            particle.rotation += particle.rotationSpeed * dt;
        });

        this.particles = this.particles.filter(particle => particle.alpha > 0.01);
    }

    spawnObjects(deltaTime) {
        this.lastObstacleSpawn += deltaTime;

        const spawnInterval = Math.max(1000 - this.speed * 25, 500);
        if (this.lastObstacleSpawn > spawnInterval) {
            this.spawnObstacle();
            this.lastObstacleSpawn = 0;
        }

        if (Math.random() < 0.004) {
            this.spawnCloud();
        }
    }

    spawnObstacle() {
        const height = 30 + Math.random() * 40;
        const width = 15 + Math.random() * 10;

        const obstacle = {
            x: this.canvas.width + 10,
            y: this.groundY,
            width: width,
            height: height,
            color: '#2e7d32',
            type: Math.random() > 0.5 ? 'cactus' : 'rock',
            sway: 0
        };

        this.obstacles.push(obstacle);

        if (Math.random() < 0.4) {
            this.spawnCoin(obstacle.x + 20, obstacle.y - obstacle.height - 60);
        }
    }

    spawnCoin(x, y) {
        const coin = {
            x: x || this.canvas.width + 10,
            y: y || this.groundY - 100 - Math.random() * 120,
            baseY: y || this.groundY - 100 - Math.random() * 120,
            width: 28,
            height: 28,
            collected: false,
            rotation: 0,
            bob: 0,
            scale: 1,
            alpha: 1,
            velocityY: 0,
            glow: 0
        };

        this.coins.push(coin);
    }

    spawnCloud() {
        const cloud = {
            x: this.canvas.width,
            y: 30 + Math.random() * 140,
            baseY: 30 + Math.random() * 140,
            width: 80 + Math.random() * 120,
            height: 40 + Math.random() * 60,
            speed: 0.8 + Math.random() * 2,
            alpha: 0.4 + Math.random() * 0.5,
            drift: 0
        };

        this.clouds.push(cloud);
    }

    checkCollisions() {
        for (let obstacle of this.obstacles) {
            if (this.dino.x < obstacle.x + obstacle.width - 5 &&
                this.dino.x + this.dino.width > obstacle.x + 5 &&
                this.dino.y < obstacle.y &&
                this.dino.y + this.dino.height > obstacle.y - obstacle.height + 5) {
                this.gameOver();
                return;
            }
        }

        for (let coin of this.coins) {
            if (!coin.collected &&
                this.dino.x < coin.x + coin.width - 5 &&
                this.dino.x + this.dino.width > coin.x + 5 &&
                this.dino.y < coin.y + coin.height - 5 &&
                this.dino.y + this.dino.height > coin.y + 5) {

                this.collectCoin(coin);
            }
        }
    }

    collectCoin(coin) {
        coin.collected = true;
        coin.velocityY = -4;

        this.coinCount += 0.5;
        this.gameState.updateCoins(0.5);
        this.gameState.updateStats('runCoinsCollected', this.gameState.stats.runCoinsCollected + 0.5);

        this.createCoinParticles(coin.x + coin.width / 2, coin.y + coin.height / 2);
    }

    createCoinParticles(x, y) {
        for (let i = 0; i < 12; i++) {
            this.particles.push({
                x: x,
                y: y,
                velocityX: (Math.random() - 0.5) * 10,
                velocityY: -Math.random() * 8 - 3,
                gravity: 0.4,
                alpha: 1,
                scale: 0.6 + Math.random() * 0.8,
                color: ['#fbbf24', '#f59e0b', '#d97706'][Math.floor(Math.random() * 3)],
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.3
            });
        }
    }

    jump() {
        if (this.dino.onGround && this.playing) {
            this.dino.velocityY = this.jumpPower;
            this.dino.onGround = false;

            // Jump particles
            for (let i = 0; i < 6; i++) {
                this.particles.push({
                    x: this.dino.x + this.dino.width / 2,
                    y: this.dino.y + this.dino.height,
                    velocityX: (Math.random() - 0.5) * 6,
                    velocityY: Math.random() * 3,
                    gravity: 0.2,
                    alpha: 0.8,
                    scale: 0.4 + Math.random() * 0.4,
                    color: '#8b5a3c',
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.2
                });
            }
        }
    }

    gameOver() {
        this.playing = false;

        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }

        if (this.score > this.gameState.stats.bestScore) {
            this.gameState.updateStats('bestScore', this.score);
            Utils.showNotification(`🏆 Новый рекорд: ${Math.floor(this.score)}!`, 'success');
        } else {
            Utils.showNotification(`💀 Игра окончена! Счёт: ${Math.floor(this.score)}`, 'error');
        }

        this.updateScore();
    }

    draw() {
        // Dynamic sky gradient based on time of day
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);

        if (this.timeOfDay < 0.5) {
            // Day time
            gradient.addColorStop(0, `hsl(200, 80%, ${65 + this.timeOfDay * 20}%)`);
            gradient.addColorStop(0.7, `hsl(180, 70%, ${75 + this.timeOfDay * 15}%)`);
            gradient.addColorStop(1, `hsl(120, 60%, ${70 + this.timeOfDay * 15}%)`);
        } else {
            // Night time
            const nightIntensity = (this.timeOfDay - 0.5) * 2;
            gradient.addColorStop(0, `hsl(240, 50%, ${20 - nightIntensity * 15}%)`);
            gradient.addColorStop(0.7, `hsl(220, 40%, ${25 - nightIntensity * 20}%)`);
            gradient.addColorStop(1, `hsl(100, 40%, ${30 - nightIntensity * 20}%)`);
        }

        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw stars at night
        if (this.timeOfDay > 0.3) {
            this.drawStars();
        }

        // Draw clouds with parallax
        this.drawClouds();

        // Draw mountains (parallax background)
        this.drawMountains();

        // Draw ground with texture
        this.drawGround();

        // Draw game objects
        this.drawDino();
        this.drawObstacles();
        this.drawCoins();
        this.drawParticles();

        // Draw UI
        this.drawUI();
    }

    drawStars() {
        this.ctx.save();
        this.stars.forEach(star => {
            star.twinkle += star.twinkleSpeed;
            const alpha = (Math.sin(star.twinkle) + 1) * 0.5 * (this.timeOfDay - 0.3) / 0.7;

            this.ctx.globalAlpha = alpha;
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        this.ctx.restore();
    }

    drawMountains() {
        this.ctx.save();

        // Far mountains
        this.ctx.fillStyle = this.timeOfDay > 0.5 ? '#2a2a4a' : '#4a6741';
        this.ctx.globalAlpha = 0.6;
        this.ctx.beginPath();
        this.ctx.moveTo(-50, this.canvas.height * 0.6);
        for (let x = 0; x < this.canvas.width + 100; x += 60) {
            this.ctx.lineTo(x + Math.sin((x + this.parallaxOffset * 0.2) * 0.01) * 20,
                           this.canvas.height * 0.5 + Math.sin((x + this.parallaxOffset * 0.2) * 0.003) * 40);
        }
        this.ctx.lineTo(this.canvas.width + 50, this.canvas.height);
        this.ctx.lineTo(0, this.canvas.height);
        this.ctx.fill();

        this.ctx.restore();
    }

    drawClouds() {
        this.ctx.save();
        this.clouds.forEach(cloud => {
            this.ctx.globalAlpha = cloud.alpha * (this.timeOfDay > 0.5 ? 0.6 : 1);
            this.ctx.fillStyle = this.timeOfDay > 0.5 ? '#e0e0e0' : '#ffffff';
            this.drawCloud(cloud.x, cloud.y, cloud.width, cloud.height);
        });
        this.ctx.restore();
    }

    drawCloud(x, y, width, height) {
        this.ctx.beginPath();
        const segments = 5;
        for (let i = 0; i < segments; i++) {
            const segmentX = x + (width / segments) * i;
            const radius = height * (0.3 + Math.random() * 0.3);
            this.ctx.arc(segmentX + width * 0.2, y + height * 0.6, radius, 0, Math.PI * 2);
        }
        this.ctx.fill();
    }

    drawGround() {
        // Ground base
        const groundGradient = this.ctx.createLinearGradient(0, this.groundY, 0, this.canvas.height);
        groundGradient.addColorStop(0, this.timeOfDay > 0.5 ? '#4a4a2a' : '#8b5a3c');
        groundGradient.addColorStop(1, this.timeOfDay > 0.5 ? '#2a2a1a' : '#6b3a1c');

        this.ctx.fillStyle = groundGradient;
        this.ctx.fillRect(0, this.groundY, this.canvas.width, this.canvas.height - this.groundY);

        // Ground line with grass effect
        this.ctx.strokeStyle = this.timeOfDay > 0.5 ? '#5d5d2d' : '#5d4037';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.groundY);
        for (let x = 0; x < this.canvas.width; x += 5) {
            this.ctx.lineTo(x, this.groundY + Math.sin((x + this.parallaxOffset) * 0.1) * 2);
        }
        this.ctx.stroke();

        // Grass blades
        this.ctx.strokeStyle = this.timeOfDay > 0.5 ? '#4a6741' : '#6b8e23';
        this.ctx.lineWidth = 2;
        for (let x = 0; x < this.canvas.width; x += 15) {
            const grassX = x + Math.sin((x + this.parallaxOffset) * 0.05) * 3;
            this.ctx.beginPath();
            this.ctx.moveTo(grassX, this.groundY);
            this.ctx.lineTo(grassX + Math.sin((x + this.parallaxOffset) * 0.02) * 3, this.groundY - 8);
            this.ctx.stroke();
        }
    }

    drawDino() {
        this.ctx.save();

        // Shadow
        this.ctx.globalAlpha = 0.3;
        this.ctx.fillStyle = '#000000';
        this.ctx.ellipse(this.dino.x + this.dino.width / 2, this.groundY, this.dino.width / 2, 8, 0, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.restore();
        this.ctx.save();

        // Dino glow effect when jumping
        if (!this.dino.onGround) {
            this.ctx.shadowColor = '#00d4ff';
            this.ctx.shadowBlur = 15;
        }

        if (this.images.dino) {
            // Slightly tilt when jumping
            if (!this.dino.onGround) {
                this.ctx.translate(this.dino.x + this.dino.width / 2, this.dino.y + this.dino.height / 2);
                this.ctx.rotate(-0.1);
                this.ctx.drawImage(this.images.dino, -this.dino.width / 2, -this.dino.height / 2, this.dino.width, this.dino.height);
            } else {
                // Running animation
                const bounce = Math.sin(this.dino.animFrame) * 2;
                this.ctx.drawImage(this.images.dino, this.dino.x, this.dino.y + bounce, this.dino.width, this.dino.height);
            }
        } else {
            // Fallback rectangle with better design
            this.ctx.fillStyle = this.dino.color;
            this.ctx.fillRect(this.dino.x, this.dino.y, this.dino.width, this.dino.height);

            // Eyes
            this.ctx.fillStyle = '#ffffff';
            this.ctx.fillRect(this.dino.x + 30, this.dino.y + 8, 5, 5);
            this.ctx.fillRect(this.dino.x + 38, this.dino.y + 8, 5, 5);

            // Pupils
            this.ctx.fillStyle = '#000000';
            this.ctx.fillRect(this.dino.x + 32, this.dino.y + 10, 2, 2);
            this.ctx.fillRect(this.dino.x + 40, this.dino.y + 10, 2, 2);
        }

        this.ctx.restore();
    }

    drawObstacles() {
        this.obstacles.forEach(obstacle => {
            this.ctx.save();

            // Shadow
            this.ctx.globalAlpha = 0.3;
            this.ctx.fillStyle = '#000000';
            this.ctx.fillRect(obstacle.x + 2, this.groundY + 2, obstacle.width, 4);

            this.ctx.restore();

            if (obstacle.type === 'cactus') {
                // Enhanced cactus with segments
                this.ctx.fillStyle = '#2e7d32';

                // Main body with slight sway
                const swayOffset = Math.sin(obstacle.sway) * 2;
                this.ctx.fillRect(obstacle.x + swayOffset, obstacle.y - obstacle.height, obstacle.width, obstacle.height);

                // Cactus segments
                for (let i = 0; i < Math.floor(obstacle.height / 15); i++) {
                    this.ctx.fillStyle = i % 2 === 0 ? '#2e7d32' : '#1b5e20';
                    this.ctx.fillRect(obstacle.x + swayOffset, obstacle.y - (i + 1) * 15, obstacle.width, 15);
                }

                // Arms
                if (obstacle.width > 15) {
                    this.ctx.fillStyle = '#2e7d32';
                    this.ctx.fillRect(obstacle.x - 8 + swayOffset, obstacle.y - obstacle.height * 0.6, 8, 25);
                    this.ctx.fillRect(obstacle.x + obstacle.width + swayOffset, obstacle.y - obstacle.height * 0.8, 8, 30);
                }

                // Spikes
                this.ctx.fillStyle = '#1b5e20';
                for (let i = 0; i < 3; i++) {
                    const spikeY = obstacle.y - obstacle.height * 0.2 - i * 8;
                    this.ctx.beginPath();
                    this.ctx.moveTo(obstacle.x + swayOffset - 2, spikeY);
                    this.ctx.lineTo(obstacle.x + swayOffset - 6, spikeY - 4);
                    this.ctx.lineTo(obstacle.x + swayOffset - 2, spikeY - 8);
                    this.ctx.fill();
                }
            } else {
                // Rock obstacle
                this.ctx.fillStyle = '#5d4037';
                this.ctx.beginPath();
                this.ctx.ellipse(obstacle.x + obstacle.width / 2, obstacle.y - obstacle.height / 2,
                                obstacle.width / 2, obstacle.height / 2, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Rock texture
                this.ctx.fillStyle = '#4a2c20';
                this.ctx.beginPath();
                this.ctx.ellipse(obstacle.x + obstacle.width / 2 - 3, obstacle.y - obstacle.height / 2 - 2,
                                obstacle.width / 4, obstacle.height / 4, 0, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });
    }

    drawCoins() {
        this.coins.forEach(coin => {
            this.ctx.save();

            // Glow effect
            if (!coin.collected) {
                this.ctx.shadowColor = '#fbbf24';
                this.ctx.shadowBlur = 10;
            }

            this.ctx.globalAlpha = coin.alpha;
            this.ctx.translate(coin.x + coin.width / 2, coin.y + coin.height / 2);
            this.ctx.rotate(coin.rotation);
            this.ctx.scale(coin.scale, coin.scale);

            if (this.images.coin) {
                this.ctx.drawImage(this.images.coin, -coin.width / 2, -coin.height / 2, coin.width, coin.height);
            } else {
                // Enhanced fallback coin
                const coinGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, coin.width / 2);
                coinGradient.addColorStop(0, '#fde047');
                coinGradient.addColorStop(0.7, '#fbbf24');
                coinGradient.addColorStop(1, '#f59e0b');

                this.ctx.fillStyle = coinGradient;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, coin.width / 2, 0, Math.PI * 2);
                this.ctx.fill();

                // Inner circle
                this.ctx.fillStyle = '#d97706';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, coin.width / 3, 0, Math.PI * 2);
                this.ctx.fill();

                // Shine effect
                this.ctx.fillStyle = '#ffffff';
                this.ctx.globalAlpha = 0.6 * coin.alpha;
                this.ctx.beginPath();
                this.ctx.arc(-coin.width / 6, -coin.width / 6, coin.width / 8, 0, Math.PI * 2);
                this.ctx.fill();
            }

            this.ctx.restore();
        });
    }

    drawParticles() {
        this.particles.forEach(particle => {
            this.ctx.save();
            this.ctx.globalAlpha = particle.alpha;
            this.ctx.fillStyle = particle.color;
            this.ctx.translate(particle.x, particle.y);
            this.ctx.rotate(particle.rotation);
            this.ctx.scale(particle.scale, particle.scale);
            this.ctx.beginPath();
            this.ctx.arc(0, 0, 3, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        });
    }

    drawUI() {
        // Enhanced UI indicators
        this.ctx.save();

        // Speed indicator
        const speedIndicator = {
            x: 15,
            y: 15,
            width: 130,
            height: 35
        };

        // Background with improved gradient
        const speedGradient = this.ctx.createLinearGradient(
            speedIndicator.x, speedIndicator.y,
            speedIndicator.x + speedIndicator.width, speedIndicator.y + speedIndicator.height
        );
        speedGradient.addColorStop(0, '#6366f1');
        speedGradient.addColorStop(1, '#8b5cf6');

        this.ctx.fillStyle = speedGradient;
        this.ctx.fillRect(speedIndicator.x, speedIndicator.y, speedIndicator.width, speedIndicator.height);

        // Border
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(speedIndicator.x, speedIndicator.y, speedIndicator.width, speedIndicator.height);

        // Icon and text
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = 'bold 18px Arial';
        this.ctx.fillText('⚡', speedIndicator.x + 10, speedIndicator.y + 24);

        this.ctx.font = 'bold 16px Arial';
        this.ctx.fillText(`${this.speed.toFixed(1)} км/ч`, speedIndicator.x + 35, speedIndicator.y + 24);

        // Coins indicator
        const coinsIndicator = {
            x: 155,
            y: 15,
            width: 110,
            height: 35
        };

        const coinsGradient = this.ctx.createLinearGradient(
            coinsIndicator.x, coinsIndicator.y,
            coinsIndicator.x + coinsIndicator.width, coinsIndicator.y + coinsIndicator.height
        );
        coinsGradient.addColorStop(0, '#f59e0b');
        coinsGradient.addColorStop(1, '#f97316');

        this.ctx.fillStyle = coinsGradient;
        this.ctx.fillRect(coinsIndicator.x, coinsIndicator.y, coinsIndicator.width, coinsIndicator.height);

        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.strokeRect(coinsIndicator.x, coinsIndicator.y, coinsIndicator.width, coinsIndicator.height);

        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = 'bold 18px Arial';
        this.ctx.fillText('🪙', coinsIndicator.x + 10, coinsIndicator.y + 24);

        this.ctx.font = 'bold 16px Arial';
        this.ctx.fillText(`${this.coinCount.toFixed(1)}`, coinsIndicator.x + 35, coinsIndicator.y + 24);

        this.ctx.restore();
    }

    updateScore() {
        const high = Math.floor(this.gameState.stats.bestScore);
        const current = Math.floor(this.score);
        this.scoreEl.textContent = `Счёт: ${current} • 🏆 Рекорд: ${high}`;
    }
}

// ====================
// UI Manager
// ====================
class UIManager {
    constructor(gameState) {
        this.gameState = gameState;
        this.init();
    }

    init() {
        this.setupOverlayControls();
        this.setupKeyboardShortcuts();
        this.setupLoadingScreen();
    }

    setupOverlayControls() {
        const overlay = document.getElementById('overlay');

        // Open/close main overlay
        document.getElementById('openGame').onclick = () => {
            overlay.classList.add('show');
            this.showGameSelection();
        };

        document.getElementById('closeGame').onclick = () => {
            overlay.classList.remove('show');
        };

        // Game selection
        document.getElementById('selectMiner').onclick = () => {
            this.showMinerGame();
        };

        document.getElementById('selectRun').onclick = () => {
            this.showRunGame();
        };

        // Game close buttons
        document.getElementById('closeMiner').onclick = () => {
            this.showGameSelection();
        };

        document.getElementById('closeRun').onclick = () => {
            this.showGameSelection();
        };

        // Click outside to close
        overlay.onclick = (e) => {
            if (e.target === overlay) {
                overlay.classList.remove('show');
            }
        };
    }

    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                const overlay = document.getElementById('overlay');
                if (overlay.classList.contains('show')) {
                    overlay.classList.remove('show');
                }
            }
        });
    }

    setupLoadingScreen() {
        const loadingScreen = document.getElementById('loadingScreen');

        // Simulate loading
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
        }, 1800);
    }

    showGameSelection() {
        document.getElementById('gameSelectCard').style.display = 'flex';
        document.getElementById('minerCard').style.display = 'none';
        document.getElementById('runCard').style.display = 'none';
    }

    showMinerGame() {
        document.getElementById('gameSelectCard').style.display = 'none';
        document.getElementById('minerCard').style.display = 'flex';
        document.getElementById('runCard').style.display = 'none';
    }

    showRunGame() {
        document.getElementById('gameSelectCard').style.display = 'none';
        document.getElementById('minerCard').style.display = 'none';
        document.getElementById('runCard').style.display = 'flex';
    }
}

// ====================
// Application Bootstrap
// ====================
class PoizonApp {
    constructor() {
        this.gameState = new GameState();
        this.calculator = new Calculator(this.gameState);
        this.minerGame = new MinerGame(this.gameState);
        this.runGame = new RunGame(this.gameState);
        this.uiManager = new UIManager(this.gameState);

        this.init();
    }

    init() {
        // Initialize UI
        this.gameState.updateUI();

        // Setup Telegram WebApp
        this.setupTelegramWebApp();

        // Setup error handling
        this.setupErrorHandling();

        console.log('🎮 Poizon App initialized successfully!');
    }

    setupTelegramWebApp() {
        try {
            if (window.Telegram && window.Telegram.WebApp) {
                const tg = window.Telegram.WebApp;
                tg.ready();
                tg.expand();
            }
        } catch (e) {
            console.warn('Telegram WebApp not available:', e);
        }
    }

    setupErrorHandling() {
        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
            Utils.showNotification('Произошла ошибка. Перезагрузите страницу.', 'error');
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
            Utils.showNotification('Произошла ошибка. Попробуйте ещё раз.', 'error');
        });
    }
}

// ====================
// Initialize App
// ====================
document.addEventListener('DOMContentLoaded', () => {
    new PoizonApp();
});

// Export for debugging
if (typeof window !== 'undefined') {
    window.PoizonApp = PoizonApp;
    window.Utils = Utils;
}
    </script>
</body>
</html>
